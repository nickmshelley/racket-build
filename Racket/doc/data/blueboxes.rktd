8761
((3) 0 () 9 ((q lib "data/gvector.rkt") (q lib "data/splay-tree.rkt") (q lib "data/integer-set.rkt") (q lib "data/skip-list.rkt") (q lib "data/order.rkt") (q lib "data/bit-vector.rkt") (q lib "data/interval-map.rkt") (q lib "data/queue.rkt") (q lib "data/heap.rkt")) () (h ! (equal) ((c def c (c (? . 4) q order-domain-contract)) q (3739 . 3)) ((c def c (c (? . 3) q make-skip-list)) q (6842 . 7)) ((c def c (c (? . 1) q splay-tree-iterate-first)) q (5165 . 3)) ((c def c (c (? . 0) q gvector)) q (923 . 3)) ((c def c (c (? . 7) q dequeue!)) q (183 . 3)) ((c def c (c (? . 0) q gvector-set!)) q (1291 . 6)) ((c def c (c (? . 2) q union)) q (14871 . 4)) ((c def c (c (? . 1) q make-splay-tree)) q (4027 . 7)) ((c def c (c (? . 1) q splay-tree->list)) q (6767 . 3)) ((c def c (c (? . 5) q bit-vector-length)) q (16503 . 3)) ((c def c (c (? . 6) q interval-map-iter?)) q (13068 . 3)) ((c def c (c (? . 2) q make-integer-set)) q (14092 . 3)) ((c def c (c (? . 2) q member?)) q (15313 . 4)) ((c def c (c (? . 2) q make-range)) q (14483 . 7)) ((c def c (c (? . 3) q skip-list-iterate-value)) q (8413 . 4)) ((c def c (c (? . 4) q order-<?)) q (3891 . 3)) ((c def c (c (? . 1) q splay-tree-iterate-greatest/<=?)) q (6578 . 5)) ((c def c (c (? . 1) q splay-tree?)) q (4601 . 3)) ((c def c (c (? . 5) q bit-vector)) q (15993 . 3)) ((c def c (c (? . 5) q bit-vector-popcount)) q (16592 . 3)) ((c def c (c (? . 4) q dict-iterate-least)) q (2352 . 3)) ((c def c (c (? . 5) q string->bit-vector)) q (17547 . 3)) ((c def c (c (? . 3) q skip-list-expand!)) q (8826 . 5)) ((c def c (c (? . 6) q interval-map-iterate-value)) q (12888 . 5)) ((c def c (c (? . 3) q skip-list-set!)) q (7708 . 5)) ((c def c (c (? . 4) q gen:ordered-dict)) q (2144 . 2)) ((c def c (c (? . 1) q splay-tree-iterate-least)) q (6013 . 3)) ((c def c (c (? . 7) q queue?)) q (559 . 3)) ((c def c (c (? . 5) q in-bit-vector)) q (16878 . 3)) ((c def c (c (? . 3) q skip-list-iter?)) q (9839 . 3)) ((c def c (c (? . 0) q make-gvector)) q (812 . 3)) ((c def c (c (? . 4) q order-=?)) q (3812 . 3)) ((c def c (c (? . 3) q skip-list-iterate-least)) q (9617 . 3)) ((c def c (c (? . 6) q interval-map-update*!)) q (10834 . 11)) ((c def c (c (? . 6) q interval-map?)) q (10220 . 3)) ((c def c (c (? . 8) q heap-count)) q (13259 . 3)) ((c def c (c (? . 8) q in-heap)) q (13904 . 3)) ((c def c (c (? . 2) q foldr)) q (15487 . 5)) ((c def c (c (? . 2) q symmetric-difference)) q (15210 . 4)) ((c def c (c (? . 2) q split)) q (14959 . 4)) ((c def c (c (? . 4) q dict-iterate-least/>?)) q (2572 . 5)) ((c def c (c (? . 5) q list->bit-vector)) q (17369 . 3)) ((c def c (c (? . 2) q set-integer-set-contents!)) q (14254 . 4)) ((c def c (c (? . 6) q interval-map-iterate-first)) q (12384 . 4)) ((c def c (c (? . 8) q heap-add!)) q (13333 . 4)) ((c def c (c (? . 8) q heap-min)) q (13508 . 3)) ((c def c (c (? . 0) q in-gvector)) q (1941 . 3)) ((c def c (c (? . 3) q skip-list-iterate-greatest/<?)) q (9255 . 6)) ((c def c (c (? . 1) q splay-tree-count)) q (5079 . 3)) ((c def c (c (? . 2) q get-integer)) q (15401 . 3)) ((c def c (c (? . 2) q count)) q (15715 . 3)) ((c def c (c (? . 6) q interval-map-ref)) q (10279 . 7)) ((c def c (c (? . 7) q queue/c)) q (737 . 2)) ((c def c (c (? . 0) q gvector-remove-last!)) q (1665 . 3)) ((c def c (c (? . 7) q non-empty-queue?)) q (611 . 3)) ((c def c (c (? . 1) q splay-tree-iterate-least/>?)) q (6206 . 4)) ((c def c (c (? . 8) q heap-add-all!)) q (13409 . 4)) ((c def c (c (? . 4) q dict-iterate-least/>=?)) q (2707 . 5)) ((c def c (c (? . 2) q complement)) q (15075 . 5)) ((c def c (c (? . 0) q gvector->list)) q (1880 . 3)) ((c def c (c (? . 4) q ordered-dict?)) q (2293 . 3)) ((c def c (c (? . 1) q splay-tree-iterate-greatest/<?)) q (6452 . 5)) ((c def c (c (? . 2) q integer-set-contents)) q (14173 . 3)) ((c def c (c (? . 7) q make-queue)) q (0 . 2)) ((c def c (c (? . 1) q adjustable-splay-tree?)) q (4658 . 3)) ((c def c (c (? . 2) q well-formed-set?)) q (14421 . 3)) ((c def c (c (? . 6) q interval-map-contract!)) q (11537 . 7)) ((c def c (c (? . 7) q queue-length)) q (415 . 3)) ((c def c (c (? . 5) q bit-vector->list)) q (17289 . 3)) ((c def c (c (? . 1) q splay-tree-iterate-greatest)) q (6108 . 3)) ((c def c (c (? . 0) q gvector-ref)) q (1041 . 5)) ((c def c (c (? . 3) q skip-list-iterate-first)) q (8040 . 3)) ((c def c (c (? . 8) q heap-copy)) q (13783 . 3)) ((c def c (c (? . 7) q nonempty-queue/c)) q (770 . 2)) ((c def c (c (? . 7) q enqueue!)) q (35 . 4)) ((c def c (c (? . 7) q in-queue)) q (673 . 3)) ((c def c (c (? . 3) q skip-list-remove!)) q (7836 . 4)) ((c def c (c (? . 5) q bit-vector?)) q (16066 . 3)) ((c def c (c (? . 3) q skip-list-ref)) q (7543 . 5)) ((c form c (c (? . 5) q for*/bit-vector)) q (17202 . 3)) ((c def c (c (? . 4) q ordering/c)) q (2108 . 2)) ((c def c (c (? . 4) q dict-iterate-greatest/<=?)) q (2981 . 5)) ((c def c (c (? . 5) q make-bit-vector)) q (15877 . 4)) ((c def c (c (? . 4) q order?)) q (3598 . 3)) ((c def c (c (? . 3) q skip-list->list)) q (9900 . 3)) ((c def c (c (? . 4) q order-comparator)) q (3650 . 3)) ((c def c (c (? . 3) q make-adjustable-skip-list)) q (7165 . 6)) ((c def c (c (? . 1) q splay-tree-iterate-next)) q (5261 . 4)) ((c def c (c (? . 1) q splay-tree-expand!)) q (5871 . 5)) ((c def c (c (? . 7) q enqueue-front!)) q (106 . 4)) ((c def c (c (? . 2) q partition)) q (15629 . 3)) ((c def c (c (? . 1) q splay-tree-ref)) q (4726 . 5)) ((c def c (c (? . 7) q queue-empty?)) q (500 . 3)) ((c def c (c (? . 4) q order)) q (3120 . 12)) ((c def c (c (? . 8) q heap-remove-min!)) q (13559 . 3)) ((c def c (c (? . 8) q in-heap/consume!)) q (13835 . 3)) ((c def c (c (? . 3) q skip-list-iterate-greatest/<=?)) q (9435 . 6)) ((c def c (c (? . 8) q heap-sort!)) q (13964 . 4)) ((c def c (c (? . 1) q splay-tree-iterate-value)) q (5499 . 4)) ((c def c (c (? . 1) q splay-tree-contract!)) q (5727 . 5)) ((c def c (c (? . 3) q skip-list-count)) q (7940 . 3)) ((c def c (c (? . 1) q make-adjustable-splay-tree)) q (4354 . 6)) ((c def c (c (? . 6) q interval-map-cons*!)) q (12023 . 11)) ((c def c (c (? . 6) q interval-map-iterate-next)) q (12509 . 6)) ((c def c (c (? . 4) q prop:ordered-dict)) q (2177 . 3)) ((c def c (c (? . 1) q splay-tree-iterate-least/>=?)) q (6328 . 5)) ((c def c (c (? . 4) q dict-iterate-greatest/<?)) q (2843 . 5)) ((c def c (c (? . 0) q gvector-remove!)) q (1494 . 5)) ((c def c (c (? . 1) q splay-tree-remove!)) q (4989 . 4)) ((c form c (c (? . 0) q for/gvector)) q (2003 . 2)) ((c def c (c (? . 3) q skip-list?)) q (7420 . 3)) ((c def c (c (? . 0) q gvector-add!)) q (1199 . 4)) ((c def c (c (? . 0) q gvector->vector)) q (1815 . 3)) ((c def c (c (? . 6) q interval-map-iterate-key)) q (12710 . 5)) ((c def c (c (? . 7) q queue->list)) q (342 . 3)) ((c def c (c (? . 3) q skip-list-iterate-key)) q (8293 . 4)) ((c def c (c (? . 2) q intersect)) q (14688 . 4)) ((c def c (c (? . 1) q splay-tree-remove-range!)) q (5608 . 5)) ((c def c (c (? . 8) q vector->heap)) q (13618 . 4)) ((c def c (c (? . 3) q skip-list-iterate-next)) q (8149 . 5)) ((c def c (c (? . 4) q dict-iterate-greatest)) q (2460 . 4)) ((c def c (c (? . 8) q make-heap)) q (13132 . 3)) ((c def c (c (? . 3) q skip-list-contract!)) q (8668 . 5)) ((c def c (c (? . 4) q real-order)) q (3970 . 2)) ((c def c (c (? . 5) q bit-vector-ref)) q (16123 . 5)) ((c def c (c (? . 3) q skip-list-remove-range!)) q (8535 . 5)) ((c def c (c (? . 6) q make-interval-map)) q (9989 . 6)) ((c def c (c (? . 5) q bit-vector->string)) q (17453 . 3)) ((c def c (c (? . 3) q skip-list-iterate-greatest)) q (9726 . 4)) ((c def c (c (? . 4) q datum-order)) q (3998 . 2)) ((c def c (c (? . 8) q heap?)) q (13208 . 3)) ((c form c (c (? . 0) q for*/gvector)) q (2055 . 2)) ((c def c (c (? . 0) q gvector?)) q (987 . 3)) ((c def c (c (? . 5) q bit-vector-copy)) q (16683 . 5)) ((c def c (c (? . 6) q interval-map-expand!)) q (11783 . 7)) ((c def c (c (? . 6) q interval-map-set!)) q (10540 . 9)) ((c def c (c (? . 7) q queue-filter!)) q (245 . 4)) ((c def c (c (? . 1) q splay-tree-iterate-key)) q (5392 . 4)) ((c def c (c (? . 5) q bit-vector-set!)) q (16287 . 6)) ((c def c (c (? . 2) q subtract)) q (14780 . 4)) ((c def c (c (? . 6) q interval-map-remove!)) q (11265 . 7)) ((c def c (c (? . 3) q skip-list-iterate-least/>=?)) q (9118 . 5)) ((c def c (c (? . 1) q splay-tree-set!)) q (4875 . 5)) ((c def c (c (? . 0) q gvector-count)) q (1733 . 3)) ((c def c (c (? . 8) q heap->vector)) q (13726 . 3)) ((c def c (c (? . 3) q skip-list-iterate-least/>?)) q (8982 . 5)) ((c def c (c (? . 2) q integer-set?)) q (14363 . 3)) ((c def c (c (? . 1) q splay-tree-iter?)) q (6705 . 3)) ((c form c (c (? . 5) q for/bit-vector)) q (16946 . 9)) ((c def c (c (? . 3) q adjustable-skip-list?)) q (7476 . 3)) ((c def c (c (? . 2) q subset?)) q (15791 . 4))))
procedure
(make-queue) -> queue?
procedure
(enqueue! q v) -> void?
  q : queue?
  v : any/c
procedure
(enqueue-front! q v) -> void?
  q : queue?
  v : any/c
procedure
(dequeue! q) -> any/c
  q : non-empty-queue?
procedure
(queue-filter! q pred?) -> void?
  q : queue?
  pred? : (-> any/c any/c)
procedure
(queue->list queue) -> (listof any/c)
  queue : queue?
procedure
(queue-length queue) -> exact-nonnegative-integer?
  queue : queue?
procedure
(queue-empty? q) -> boolean?
  q : queue?
procedure
(queue? v) -> boolean?
  v : any/c
procedure
(non-empty-queue? v) -> boolean?
  v : any/c
procedure
(in-queue queue) -> sequence?
  queue : queue?
value
queue/c : flat-contract?
value
nonempty-queue/c : flat-contract?
procedure
(make-gvector [#:capacity capacity]) -> gvector?
  capacity : exact-positive-integer? = 10
procedure
(gvector elem ...) -> gvector?
  elem : any/c
procedure
(gvector? x) -> boolean?
  x : any/c
procedure
(gvector-ref gv index [default]) -> any/c
  gv : gvector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
procedure
(gvector-add! gv value ...) -> void?
  gv : gvector?
  value : any/c
procedure
(gvector-set! gv index value) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (gvector-count gv))))
  value : any/c
procedure
(gvector-remove! gv index) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (gvector-count gv)))
procedure
(gvector-remove-last! gv) -> any/c
  gv : gvector?
procedure
(gvector-count gv) -> exact-nonnegative-integer?
  gv : gvector?
procedure
(gvector->vector gv) -> vector?
  gv : gvector?
procedure
(gvector->list gv) -> list?
  gv : gvector?
procedure
(in-gvector gv) -> sequence?
  gv : gvector?
syntax
(for/gvector (for-clause ...) body ...+)
syntax
(for*/gvector (for-clause ...) body ...+)
value
ordering/c : flat-contract?
value
gen:ordered-dict : any/c
value
prop:ordered-dict : (struct-type-property/c
                     (vectorof e/c e/c s/c s/c s/c s/c))
procedure
(ordered-dict? x) -> boolean?
  x : any/c
procedure
(dict-iterate-least dict) -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
procedure
(dict-iterate-greatest dict)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
procedure
(dict-iterate-least/>? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-least/>=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-greatest/<? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-greatest/<=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(order name domain-contract comparator)
 -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  comparator : (-> any/c any/c ordering/c)
(order name domain-contract =? <? [>?]) -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  =? : (-> any/c any/c boolean?)
  <? : (-> any/c any/c boolean?)
  >? : (-> any/c any/c boolean?) = (lambda (x y) (<? y x))
procedure
(order? x) -> boolean?
  x : any/c
procedure
(order-comparator ord) -> (-> any/c any/c ordering/c)
  ord : order?
procedure
(order-domain-contract ord) -> contract?
  ord : order?
procedure
(order-=? ord) -> (-> any/c any/c boolean?)
  ord : order?
procedure
(order-<? ord) -> (-> any/c any/c boolean?)
  ord : order?
value
real-order : order?
value
datum-order : order?
procedure
(make-splay-tree [ord                                   
                  #:key-contract key-contract           
                  #:value-contract value-contract]) -> splay-tree?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(make-adjustable-splay-tree [#:key-contract key-contract       
                             #:value-contract value-contract]) 
 -> splay-tree?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(splay-tree? x) -> boolean?
  x : any/c
procedure
(adjustable-splay-tree? x) -> boolean?
  x : any/c
procedure
(splay-tree-ref s key [default]) -> any
  s : splay-tree?
  key : any/c
  default : any/c = (lambda () (error ....))
procedure
(splay-tree-set! s key value) -> void?
  s : splay-tree?
  key : any/c
  value : any/c
procedure
(splay-tree-remove! s key) -> void?
  s : splay-tree?
  key : any/c
procedure
(splay-tree-count s) -> exact-nonnegative-integer?
  s : splay-tree?
procedure
(splay-tree-iterate-first s) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
procedure
(splay-tree-iterate-next s iter) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-iterate-key s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-iterate-value s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-remove-range! s from to) -> void?
  s : splay-tree?
  from : any/c
  to : any/c
procedure
(splay-tree-contract! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
procedure
(splay-tree-expand! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
procedure
(splay-tree-iterate-least s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
procedure
(splay-tree-iterate-greatest s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
procedure
(splay-tree-iterate-least/>? s key) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-least/>=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-greatest/<? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-greatest/<=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iter? x) -> boolean?
  x : any/c
procedure
(splay-tree->list s) -> (listof pair?)
  s : splay-tree?
procedure
(make-skip-list [ord                                   
                 #:key-contract key-contract           
                 #:value-contract value-contract]) -> skip-list?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(make-adjustable-skip-list [#:key-contract key-contract       
                            #:value-contract value-contract]) 
 -> adjustable-skip-list?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(skip-list? v) -> boolean?
  v : any/c
procedure
(adjustable-skip-list? v) -> boolean?
  v : any/c
procedure
(skip-list-ref skip-list key [default]) -> any/c
  skip-list : skip-list?
  key : any/c
  default : any/c = (lambda () (error ....))
procedure
(skip-list-set! skip-list key value) -> void?
  skip-list : skip-list?
  key : any/c
  value : any/c
procedure
(skip-list-remove! skip-list key) -> void?
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-count skip-list) -> exact-nonnegative-integer?
  skip-list : skip-list?
procedure
(skip-list-iterate-first skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iterate-next skip-list iter)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-iterate-key skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-iterate-value skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-remove-range! skip-list from to) -> void?
  skip-list : skip-list?
  from : any/c
  to : any/c
procedure
(skip-list-contract! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
procedure
(skip-list-expand! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
procedure
(skip-list-iterate-least/>? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-least/>=? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-greatest/<? skip-list 
                               key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-greatest/<=? skip-list 
                                key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-least skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iterate-greatest skip-list)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iter? v) -> boolean?
  v : any/c
procedure
(skip-list->list skip-list) -> (listof pair?)
  skip-list : skip-list?
procedure
(make-interval-map [#:key-contract key-contract       
                    #:value-contract value-contract]) 
 -> interval-map?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(interval-map? v) -> boolean?
  v : any/c
procedure
(interval-map-ref  interval-map     
                   position         
                  [default])    -> any/c
  interval-map : interval-map?
  position : exact-integer?
  default : any/c = (lambda () (error ....))
procedure
(interval-map-set! interval-map     
                   start            
                   end              
                   value)       -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  value : any/c
procedure
(interval-map-update*!  interval-map     
                        start            
                        end              
                        updater          
                       [default])    -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  updater : (-> any/c any/c)
  default : any/c = (lambda () (error ....))
procedure
(interval-map-remove! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : (or/c exact-integer? -inf.0)
  end : (or/c exact-integer? +inf.0)
procedure
(interval-map-contract! interval-map     
                        start            
                        end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
procedure
(interval-map-expand! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
procedure
(interval-map-cons*!  interval-map     
                      start            
                      end              
                      v                
                     [default])    -> void?
  interval-map : interval-map?
  start : any/c
  end : any/c
  v : any/c
  default : any/c = null
procedure
(interval-map-iterate-first interval-map)
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
procedure
(interval-map-iterate-next interval-map 
                           iter)        
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iterate-key interval-map     
                          iter)        -> pair?
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iterate-value interval-map     
                            iter)        -> any
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iter? v) -> boolean?
  v : any/c
procedure
(make-heap <=?) -> heap?
  <=? : (-> any/c any/c any/c)
procedure
(heap? x) -> boolean?
  x : any/c
procedure
(heap-count h) -> exact-nonnegative-integer?
  h : heap?
procedure
(heap-add! h v ...) -> void?
  h : heap?
  v : any/c
procedure
(heap-add-all! h v) -> void?
  h : heap?
  v : (or/c list? vector? heap?)
procedure
(heap-min h) -> any/c
  h : heap?
procedure
(heap-remove-min! h) -> void?
  h : heap?
procedure
(vector->heap <=? items) -> heap?
  <=? : (-> any/c any/c any/c)
  items : vector?
procedure
(heap->vector h) -> vector?
  h : heap?
procedure
(heap-copy h) -> heap?
  h : heap?
procedure
(in-heap/consume! heap) -> sequence?
  heap : heap?
procedure
(in-heap heap) -> sequence?
  heap : heap?
procedure
(heap-sort! v <=?) -> void?
  v : (and/c vector? (not/c immutable?))
  <=? : (-> any/c any/c any/c)
procedure
(make-integer-set wfs) -> integer-set?
  wfs : well-formed-set?
procedure
(integer-set-contents s) -> well-formed-set?
  s : integer-set?
procedure
(set-integer-set-contents! s wfs) -> void?
  s : integer-set?
  wfs : well-formed-set?
procedure
(integer-set? v) -> boolean?
  v : any/c
procedure
(well-formed-set? v) -> boolean?
  v : any/c
procedure
(make-range) -> integer-set?
(make-range elem) -> integer-set?
  elem : exact-integer?
(make-range start end) -> integer-set?
  start : exact-integer?
  end : exact-integer?
procedure
(intersect x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(subtract x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(union x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(split x y) -> integer-set? integer-set? integer-set?
  x : integer-set?
  y : integer-set?
procedure
(complement s start end) -> integer-set?
  s : integer-set?
  start : exact-integer?
  end : exact-integer?
procedure
(symmetric-difference x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(member? k s) -> boolean?
  k : exact-integer?
  s : integer-set?
procedure
(get-integer set) -> (or/c exact-integer? #f)
  set : integer-set?
procedure
(foldr proc base-v s) -> any/c
  proc : (exact-integer? any/c . -> . any/c)
  base-v : any/c
  s : integer-set?
procedure
(partition s) -> (listof integer-set?)
  s : (listof integer-set?)
procedure
(count s) -> exact-nonnegative-integer?
  s : integer-set?
procedure
(subset? x y) -> boolean?
  x : integer-set?
  y : integer-set?
procedure
(make-bit-vector size [fill]) -> bit-vector?
  size : exact-integer?
  fill : boolean? = #f
procedure
(bit-vector elem ...) -> bit-vector?
  elem : boolean?
procedure
(bit-vector? v) -> boolean?
  v : any/c
procedure
(bit-vector-ref bv index [default]) -> any/c
  bv : bit-vector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
procedure
(bit-vector-set! bv index value) -> void?
  bv : bit-vector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (bit-vector-length vv))))
  value : boolean?
procedure
(bit-vector-length bv) -> exact-nonnegative-integer?
  bv : bit-vector?
procedure
(bit-vector-popcount bv) -> exact-nonnegative-integer?
  bv : bit-vector?
procedure
(bit-vector-copy bv [start end]) -> bit-vector?
  bv : bit-vector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(in-bit-vector bv) -> sequence?
  bv : bit-vector?
syntax
(for/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
syntax
(for*/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
procedure
(bit-vector->list bv) -> (listof boolean?)
  bv : bit-vector?
procedure
(list->bit-vector bits) -> bit-vector?
  bits : (listof boolean?)
procedure
(bit-vector->string bv) -> (and/c string? #rx"^[01]*$")
  bv : bit-vector?
procedure
(string->bit-vector s) -> bit-vector?
  s : (and/c string? #rx"^[01]*$")
