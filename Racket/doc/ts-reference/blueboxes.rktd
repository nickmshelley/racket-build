14527
((3) 0 () 7 ((q lib "typed-racket/base-env/prims.rkt") (q lib "typed-racket/base-env/base-types.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed/racket/base.rkt") (q lib "typed/scheme/base.rkt")) () (h ! (equal) ((c form c (c (? . 1) q Channelof)) q (3121 . 2)) ((c form c (c (? . 0) q case-lambda:)) q (4639 . 2)) ((c form c (c (? . 0) q define:)) q (7597 . 5)) ((c form c (c (? . 0) q make-predicate)) q (8556 . 2)) ((c form c (c (? . 0) q lambda)) q (9314 . 2)) ((c form c (c (? . 1) q FlVector)) q (3062 . 2)) ((c form c (c (? . 1) q Number)) q (26 . 2)) ((c form c (c (? . 1) q Single-Flonum-Nan)) q (1053 . 2)) ((c form c (c (? . 1) q Float-Zero)) q (759 . 2)) ((c form c (c (? . 1) q Semaphore)) q (2734 . 2)) ((c form c (c (? . 1) q Syntaxof)) q (3329 . 2)) ((c form c (c (? . 0) q letrec:)) q (4061 . 2)) ((c form c (c (? . 0) q for/vector:)) q (5549 . 2)) ((c form c (c (? . 2) q Un)) q (10587 . 2)) ((c form c (c (? . 1) q Sequenceof)) q (3228 . 2)) ((c form c (c (? . 1) q Promise)) q (3187 . 2)) ((c form c (c (? . 1) q Single-Flonum-Complex)) q (213 . 2)) ((c form c (c (? . 1) q Positive-Index)) q (1611 . 2)) ((c form c (c (? . 1) q Syntax)) q (3368 . 2)) ((c form c (c (? . 2) q Refinement)) q (11217 . 2)) ((c form c (c (? . 2) q Class)) q (11138 . 2)) ((c form c (c (? . 0) q for*/hasheq:)) q (6231 . 2)) ((c form c (c (? . 0) q lambda:)) q (4400 . 6)) ((c form c (c (? . 0) q for*/fold:)) q (7283 . 4)) ((c form c (c (? . 1) q Exact-Positive-Integer)) q (289 . 2)) ((c form c (c (? . 1) q Special-Comment)) q (2358 . 2)) ((c def c (c (? . 0) q index?)) q (9787 . 3)) ((c form c (c (? . 1) q Positive-Exact-Rational)) q (1317 . 2)) ((c form c (c (? . 1) q Negative-Flonum)) q (575 . 2)) ((c form c (c (? . 1) q Vectorof)) q (3017 . 2)) ((c form c (c (? . 2) q Vector)) q (3038 . 2)) ((c form c (c (? . 1) q Futureof)) q (3207 . 2)) ((c form c (c (? . 1) q Nonnegative-Flonum)) q (527 . 2)) ((c form c (c (? . 1) q Namespace)) q (2022 . 2)) ((c form c (c (? . 1) q String)) q (1785 . 2)) ((c form c (c (? . 2) q ∀)) q (3866 . 2)) ((c def c (c (? . 3) q assert)) q (9514 . 6)) ((c form c (c (? . 1) q Negative-Single-Flonum)) q (894 . 2)) ((c form c (c (? . 1) q Log-Level)) q (2631 . 2)) ((c form c (c (? . 0) q for*:)) q (7124 . 3)) ((c form c (c (? . 0) q pdefine:)) q (10554 . 2)) ((c form c (c (? . 1) q Inexact-Real-Negative-Zero)) q (1200 . 2)) ((c form c (c (? . 0) q with-asserts)) q (9629 . 5)) ((c form c (c (? . 1) q Zero)) q (445 . 2)) ((c form c (c (? . 1) q Datum)) q (3429 . 2)) ((c form c (c (? . 1) q Nonpositive-Float)) q (598 . 2)) ((c form c (c (? . 1) q Listof)) q (2844 . 2)) ((c form c (c (? . 1) q Byte-Regexp)) q (1970 . 2)) ((c form c (c (? . 1) q Flonum-Zero)) q (777 . 2)) ((c form c (c (? . 1) q Thread-Group)) q (2662 . 2)) ((c form c (c (? . 1) q Null)) q (2089 . 2)) ((c form c (c (? . 1) q Integer)) q (55 . 2)) ((c form c (c (? . 1) q Negative-Real)) q (1492 . 2)) ((c form c (c (? . 0) q for*/first:)) q (6651 . 2)) ((c form c (c (? . 0) q do:)) q (7412 . 7)) ((c form c (c (? . 1) q Bytes-Converter)) q (2456 . 2)) ((c form c (c (? . 0) q let*-values:)) q (4272 . 2)) ((c form c (c (? . 1) q Float-Complex)) q (192 . 2)) ((c form c (c (? . 0) q for*/flvector:)) q (6442 . 2)) ((c form c (c (? . 1) q Float-Negative-Zero)) q (649 . 2)) ((c form c (c (? . 0) q define-predicate)) q (8583 . 2)) ((c form c (c (? . 0) q struct:)) q (7748 . 11)) ((c form c (c (? . 1) q Complex)) q (40 . 2)) ((c form c (c (? . 1) q TCP-Listener)) q (2577 . 2)) ((c form c (c (? . 1) q Pretty-Print-Style-Table)) q (2326 . 2)) ((c form c (c (? . 2) q Rec)) q (3801 . 2)) ((c form c (c (? . 1) q Sexpof)) q (3398 . 2)) ((c form c (c (? . 1) q Negative-Integer)) q (394 . 2)) ((c form c (c (? . 2) q Parameterof)) q (3143 . 3)) ((c form c (c (? . 0) q :type)) q (10004 . 2)) ((c form c (c (? . 0) q :query-type/result)) q (10083 . 2)) ((c form c (c (? . 1) q Variable-Reference)) q (2063 . 2)) ((c form c (c (? . 2) q Opaque)) q (3896 . 2)) ((c form c (c (? . 1) q Positive-Float)) q (457 . 2)) ((c form c (c (? . 0) q for/and:)) q (5689 . 2)) ((c form c (c (? . 1) q Prompt-Tagof)) q (3442 . 2)) ((c form c (c (? . 1) q Custodian)) q (2503 . 2)) ((c form c (c (? . 1) q Positive-Single-Flonum)) q (831 . 2)) ((c form c (c (? . 1) q One)) q (1554 . 2)) ((c form c (c (? . 0) q let:)) q (3915 . 3)) ((c form c (c (? . 1) q Place)) q (2700 . 2)) ((c form c (c (? . 1) q Syntax-E)) q (3382 . 2)) ((c def c (c (? . 3) q defined?)) q (9733 . 3)) ((c form c (c (? . 1) q Single-Flonum-Zero)) q (1027 . 2)) ((c form c (c (? . 1) q Option)) q (3877 . 2)) ((c form c (c (? . 1) q Module-Path-Index)) q (2177 . 2)) ((c form c (c (? . 0) q :)) q (8618 . 2)) ((c form c (c (? . 1) q Negative-Inexact-Real)) q (1139 . 2)) ((c form c (c (? . 0) q for*/list:)) q (6095 . 2)) ((c form c (c (? . 1) q Struct-Type-Property)) q (2381 . 2)) ((c form c (c (? . 1) q Keyword)) q (1799 . 2)) ((c form c (c (? . 1) q Undefined)) q (2141 . 2)) ((c form c (c (? . 0) q provide:)) q (8635 . 2)) ((c form c (c (? . 1) q Inexact-Complex)) q (242 . 2)) ((c form c (c (? . 0) q λ)) q (9328 . 2)) ((c form c (c (? . 1) q Natural)) q (379 . 2)) ((c form c (c (? . 4) q with-type)) q (10117 . 10)) ((c form c (c (? . 0) q pcase-lambda:)) q (4683 . 2)) ((c form c (c (? . 0) q popt-lambda:)) q (4981 . 2)) ((c form c (c (? . 0) q require/typed/provide)) q (9243 . 2)) ((c form c (c (? . 1) q Negative-Float)) q (553 . 2)) ((c form c (c (? . 1) q Internal-Definition-Context)) q (2291 . 2)) ((c form c (c (? . 1) q UDP-Socket)) q (2559 . 2)) ((c form c (c (? . 2) q Struct)) q (3820 . 2)) ((c form c (c (? . 0) q ann)) q (8684 . 2)) ((c form c (c (? . 1) q HashTable)) q (3078 . 2)) ((c form c (c (? . 0) q for*/hasheqv:)) q (6301 . 2)) ((c form c (c (? . 0) q for/or:)) q (5755 . 2)) ((c form c (c (? . 1) q Procedure)) q (3624 . 2)) ((c form c (c (? . 1) q Real-Zero)) q (1537 . 2)) ((c form c (c (? . 0) q require/typed)) q (8790 . 12)) ((c form c (c (? . 1) q Ephemeronof)) q (3305 . 2)) ((c form c (c (? . 0) q require/opaque-type)) q (10463 . 2)) ((c form c (c (? . 1) q Sexp)) q (3417 . 2)) ((c form c (c (? . 2) q ->)) q (3506 . 5)) ((c form c (c (? . 1) q Namespace-Anchor)) q (2039 . 2)) ((c form c (c (? . 1) q MPairof)) q (2976 . 2)) ((c form c (c (? . 0) q for/hash:)) q (5343 . 2)) ((c form c (c (? . 2) q All)) q (3713 . 2)) ((c form c (c (? . 1) q Single-Flonum-Negative-Zero)) q (957 . 2)) ((c form c (c (? . 1) q Flonum-Negative-Zero)) q (676 . 2)) ((c form c (c (? . 2) q mu)) q (10597 . 2)) ((c form c (c (? . 1) q Identifier)) q (3350 . 2)) ((c form c (c (? . 2) q U)) q (3641 . 2)) ((c form c (c (? . 0) q for/fold:)) q (7019 . 4)) ((c form c (c (? . 0) q with-handlers)) q (9293 . 2)) ((c form c (c (? . 0) q for/first:)) q (5824 . 2)) ((c form c (c (? . 0) q for:)) q (5030 . 10)) ((c form c (c (? . 1) q Pairof)) q (2822 . 2)) ((c form c (c (? . 1) q Single-Flonum)) q (97 . 2)) ((c form c (c (? . 1) q Positive-Fixnum)) q (1647 . 2)) ((c form c (c (? . 6) q require-typed-struct)) q (11110 . 2)) ((c form c (c (? . 5) q define-type)) q (8493 . 3)) ((c form c (c (? . 1) q Input-Port)) q (1852 . 2)) ((c form c (c (? . 1) q Read-Table)) q (2438 . 2)) ((c form c (c (? . 1) q Nonpositive-Integer)) q (418 . 2)) ((c def c (c (? . 0) q default-continuation-prompt-tag)) q (9352 . 3)) ((c form c (c (? . 1) q Nonnegative-Float)) q (502 . 2)) ((c form c (c (? . 1) q Inexact-Real-Zero)) q (1268 . 2)) ((c form c (c (? . 1) q Continuation-Mark-Set)) q (2112 . 2)) ((c form c (c (? . 1) q False)) q (1772 . 2)) ((c form c (c (? . 0) q for*/sum:)) q (6788 . 2)) ((c form c (c (? . 1) q Path-For-Some-System)) q (1913 . 2)) ((c form c (c (? . 1) q Nonnegative-Inexact-Real)) q (1107 . 2)) ((c form c (c (? . 0) q plambda:)) q (4594 . 2)) ((c form c (c (? . 0) q define-type-alias)) q (10411 . 2)) ((c form c (c (? . 1) q Compiled-Expression)) q (2264 . 2)) ((c form c (c (? . 1) q Nonnegative-Real)) q (1468 . 2)) ((c form c (c (? . 1) q Positive-Byte)) q (1577 . 2)) ((c form c (c (? . 1) q Char)) q (1828 . 2)) ((c form c (c (? . 1) q Thread-Cellof)) q (3279 . 2)) ((c form c (c (? . 0) q cast)) q (8722 . 2)) ((c form c (c (? . 1) q Symbol)) q (1814 . 2)) ((c form c (c (? . 0) q :print-type)) q (10022 . 2)) ((c form c (c (? . 1) q Log-Receiver)) q (2611 . 2)) ((c form c (c (? . 1) q Boolean)) q (1745 . 2)) ((c form c (c (? . 0) q require-typed-struct/provide)) q (10518 . 2)) ((c form c (c (? . 0) q let/cc:)) q (4332 . 2)) ((c form c (c (? . 0) q for*)) q (7400 . 2)) ((c form c (c (? . 1) q Flonum-Positive-Zero)) q (731 . 2)) ((c form c (c (? . 1) q Resolved-Module-Path)) q (2202 . 2)) ((c form c (c (? . 1) q Nonpositive-Exact-Rational)) q (1413 . 2)) ((c form c (c (? . 1) q Real)) q (160 . 2)) ((c form c (c (? . 1) q Path)) q (1901 . 2)) ((c form c (c (? . 1) q Pseudo-Random-Generator)) q (2772 . 2)) ((c form c (c (? . 0) q λ:)) q (4564 . 2)) ((c form c (c (? . 1) q Compiled-Module-Expression)) q (2230 . 2)) ((c form c (c (? . 0) q define-struct:)) q (8053 . 11)) ((c form c (c (? . 1) q Continuation-Mark-Keyof)) q (3470 . 2)) ((c form c (c (? . 1) q Nonpositive-Fixnum)) q (1719 . 2)) ((c form c (c (? . 1) q Float-Positive-Zero)) q (704 . 2)) ((c form c (c (? . 0) q for*/lists:)) q (7189 . 4)) ((c form c (c (? . 0) q declare-refinement)) q (11185 . 2)) ((c form c (c (? . 2) q List*)) q (2926 . 2)) ((c form c (c (? . 2) q case→)) q (3851 . 2)) ((c form c (c (? . 1) q Nonnegative-Integer)) q (319 . 2)) ((c form c (c (? . 1) q Regexp)) q (1941 . 2)) ((c form c (c (? . 0) q for*/or:)) q (6581 . 2)) ((c form c (c (? . 0) q let*:)) q (4107 . 2)) ((c form c (c (? . 0) q for*/vector:)) q (6372 . 2)) ((c form c (c (? . 1) q Exact-Nonnegative-Integer)) q (346 . 2)) ((c form c (c (? . 4) q #%top-interaction)) q (9479 . 2)) ((c form c (c (? . 2) q pred)) q (10570 . 2)) ((c form c (c (? . 1) q Subprocess)) q (2682 . 2)) ((c form c (c (? . 1) q Setof)) q (3103 . 2)) ((c form c (c (? . 1) q Flonum-Nan)) q (813 . 2)) ((c form c (c (? . 1) q Output-Port)) q (1870 . 2)) ((c form c (c (? . 1) q Custodian-Boxof)) q (3251 . 2)) ((c form c (c (? . 5) q values)) q (10649 . 2)) ((c form c (c (? . 1) q Path-String)) q (2803 . 2)) ((c form c (c (? . 0) q opt-lambda:)) q (4738 . 6)) ((c form c (c (? . 0) q for/list:)) q (5276 . 2)) ((c form c (c (? . 1) q Nonnegative-Single-Flonum)) q (861 . 2)) ((c form c (c (? . 1) q Inspector)) q (2520 . 2)) ((c form c (c (? . 1) q Void)) q (1840 . 2)) ((c form c (c (? . 1) q Inexact-Real-Nan)) q (1293 . 2)) ((c form c (c (? . 1) q Byte)) q (1565 . 2)) ((c form c (c (? . 2) q Tuple)) q (10607 . 2)) ((c form c (c (? . 0) q for/sum:)) q (5959 . 2)) ((c form c (c (? . 0) q inst)) q (8742 . 2)) ((c form c (c (? . 1) q Nonnegative-Exact-Rational)) q (1348 . 2)) ((c form c (c (? . 0) q for*/hash:)) q (6163 . 2)) ((c form c (c (? . 0) q for)) q (7389 . 2)) ((c form c (c (? . 0) q define-typed-struct/exec)) q (11241 . 2)) ((c form c (c (? . 1) q Inexact-Real-Positive-Zero)) q (1234 . 2)) ((c form c (c (? . 1) q Float)) q (70 . 2)) ((c form c (c (? . 0) q letrec-values:)) q (4210 . 2)) ((c form c (c (? . 1) q Byte-PRegexp)) q (1989 . 2)) ((c form c (c (? . 2) q case->)) q (3660 . 2)) ((c form c (c (? . 1) q Nonpositive-Inexact-Real)) q (1168 . 2)) ((c form c (c (? . 1) q Impersonator-Property)) q (2409 . 2)) ((c form c (c (? . 1) q Any)) q (0 . 2)) ((c form c (c (? . 1) q Exact-Number)) q (172 . 2)) ((c form c (c (? . 1) q Logger)) q (2597 . 2)) ((c form c (c (? . 0) q for/hasheq:)) q (5410 . 2)) ((c form c (c (? . 1) q Bytes)) q (2009 . 2)) ((c form c (c (? . 0) q for/hasheqv:)) q (5479 . 2)) ((c form c (c (? . 1) q Float-Nan)) q (796 . 2)) ((c form c (c (? . 1) q Thread)) q (2648 . 2)) ((c form c (c (? . 2) q Values)) q (3739 . 2)) ((c form c (c (? . 0) q for*/last:)) q (6720 . 2)) ((c form c (c (? . 1) q Will-Executor)) q (2751 . 2)) ((c form c (c (? . 0) q typecheck-fail)) q (9839 . 8)) ((c form c (c (? . 0) q for/last:)) q (5892 . 2)) ((c form c (c (? . 0) q for/product:)) q (6025 . 2)) ((c form c (c (? . 1) q Positive-Integer)) q (265 . 2)) ((c form c (c (? . 1) q EOF)) q (2101 . 2)) ((c form c (c (? . 1) q Module-Path)) q (2158 . 2)) ((c form c (c (? . 1) q Security-Guard)) q (2537 . 2)) ((c form c (c (? . 1) q Nothing)) q (11 . 2)) ((c form c (c (? . 1) q Positive-Flonum)) q (479 . 2)) ((c form c (c (? . 1) q Negative-Exact-Rational)) q (1382 . 2)) ((c form c (c (? . 4) q #%module-begin)) q (9444 . 2)) ((c form c (c (? . 0) q plet:)) q (4007 . 2)) ((c form c (c (? . 0) q for*/product:)) q (6855 . 2)) ((c form c (c (? . 1) q Parameterization)) q (2479 . 2)) ((c form c (c (? . 2) q Instance)) q (11164 . 2)) ((c form c (c (? . 0) q let-values:)) q (4151 . 2)) ((c form c (c (? . 1) q Single-Flonum-Positive-Zero)) q (992 . 2)) ((c form c (c (? . 0) q for/flvector:)) q (5618 . 2)) ((c form c (c (? . 0) q define)) q (9338 . 2)) ((c form c (c (? . 1) q Exact-Rational)) q (138 . 2)) ((c form c (c (? . 6) q require/typed)) q (10663 . 12)) ((c form c (c (? . 0) q for/lists:)) q (6926 . 4)) ((c form c (c (? . 1) q Flonum)) q (83 . 2)) ((c form c (c (? . 1) q Nonnegative-Fixnum)) q (1670 . 2)) ((c form c (c (? . 1) q MListof)) q (2956 . 2)) ((c form c (c (? . 1) q Nonpositive-Single-Flonum)) q (924 . 2)) ((c form c (c (? . 1) q Index)) q (1598 . 2)) ((c form c (c (? . 2) q List)) q (2863 . 2)) ((c form c (c (? . 1) q PRegexp)) q (1955 . 2)) ((c form c (c (? . 1) q Nonpositive-Real)) q (1513 . 2)) ((c form c (c (? . 0) q :query-type/args)) q (10046 . 2)) ((c form c (c (? . 1) q Pair)) q (10637 . 2)) ((c form c (c (? . 0) q require-typed-struct)) q (10490 . 2)) ((c form c (c (? . 0) q let/ec:)) q (4366 . 2)) ((c form c (c (? . 0) q define-typed-struct)) q (10436 . 2)) ((c form c (c (? . 1) q Nonpositive-Flonum)) q (623 . 2)) ((c form c (c (? . 1) q Negative-Fixnum)) q (1696 . 2)) ((c form c (c (? . 1) q Positive-Real)) q (1447 . 2)) ((c form c (c (? . 1) q Fixnum)) q (1633 . 2)) ((c form c (c (? . 0) q define-struct/exec:)) q (8367 . 5)) ((c form c (c (? . 1) q True)) q (1760 . 2)) ((c form c (c (? . 0) q for*/and:)) q (6514 . 2)) ((c form c (c (? . 1) q Port)) q (1889 . 2)) ((c form c (c (? . 1) q Positive-Inexact-Real)) q (1078 . 2)) ((c form c (c (? . 1) q Place-Channel)) q (2713 . 2)) ((c form c (c (? . 2) q →)) q (3840 . 2)) ((c form c (c (? . 1) q Boxof)) q (2999 . 2)) ((c form c (c (? . 1) q Inexact-Real)) q (118 . 2)) ((c form c (c (? . 2) q Parameter)) q (10620 . 2))))
syntax
Any
syntax
Nothing
syntax
Number
syntax
Complex
syntax
Integer
syntax
Float
syntax
Flonum
syntax
Single-Flonum
syntax
Inexact-Real
syntax
Exact-Rational
syntax
Real
syntax
Exact-Number
syntax
Float-Complex
syntax
Single-Flonum-Complex
syntax
Inexact-Complex
syntax
Positive-Integer
syntax
Exact-Positive-Integer
syntax
Nonnegative-Integer
syntax
Exact-Nonnegative-Integer
syntax
Natural
syntax
Negative-Integer
syntax
Nonpositive-Integer
syntax
Zero
syntax
Positive-Float
syntax
Positive-Flonum
syntax
Nonnegative-Float
syntax
Nonnegative-Flonum
syntax
Negative-Float
syntax
Negative-Flonum
syntax
Nonpositive-Float
syntax
Nonpositive-Flonum
syntax
Float-Negative-Zero
syntax
Flonum-Negative-Zero
syntax
Float-Positive-Zero
syntax
Flonum-Positive-Zero
syntax
Float-Zero
syntax
Flonum-Zero
syntax
Float-Nan
syntax
Flonum-Nan
syntax
Positive-Single-Flonum
syntax
Nonnegative-Single-Flonum
syntax
Negative-Single-Flonum
syntax
Nonpositive-Single-Flonum
syntax
Single-Flonum-Negative-Zero
syntax
Single-Flonum-Positive-Zero
syntax
Single-Flonum-Zero
syntax
Single-Flonum-Nan
syntax
Positive-Inexact-Real
syntax
Nonnegative-Inexact-Real
syntax
Negative-Inexact-Real
syntax
Nonpositive-Inexact-Real
syntax
Inexact-Real-Negative-Zero
syntax
Inexact-Real-Positive-Zero
syntax
Inexact-Real-Zero
syntax
Inexact-Real-Nan
syntax
Positive-Exact-Rational
syntax
Nonnegative-Exact-Rational
syntax
Negative-Exact-Rational
syntax
Nonpositive-Exact-Rational
syntax
Positive-Real
syntax
Nonnegative-Real
syntax
Negative-Real
syntax
Nonpositive-Real
syntax
Real-Zero
syntax
One
syntax
Byte
syntax
Positive-Byte
syntax
Index
syntax
Positive-Index
syntax
Fixnum
syntax
Positive-Fixnum
syntax
Nonnegative-Fixnum
syntax
Negative-Fixnum
syntax
Nonpositive-Fixnum
syntax
Boolean
syntax
True
syntax
False
syntax
String
syntax
Keyword
syntax
Symbol
syntax
Char
syntax
Void
syntax
Input-Port
syntax
Output-Port
syntax
Port
syntax
Path
syntax
Path-For-Some-System
syntax
Regexp
syntax
PRegexp
syntax
Byte-Regexp
syntax
Byte-PRegexp
syntax
Bytes
syntax
Namespace
syntax
Namespace-Anchor
syntax
Variable-Reference
syntax
Null
syntax
EOF
syntax
Continuation-Mark-Set
syntax
Undefined
syntax
Module-Path
syntax
Module-Path-Index
syntax
Resolved-Module-Path
syntax
Compiled-Module-Expression
syntax
Compiled-Expression
syntax
Internal-Definition-Context
syntax
Pretty-Print-Style-Table
syntax
Special-Comment
syntax
Struct-Type-Property
syntax
Impersonator-Property
syntax
Read-Table
syntax
Bytes-Converter
syntax
Parameterization
syntax
Custodian
syntax
Inspector
syntax
Security-Guard
syntax
UDP-Socket
syntax
TCP-Listener
syntax
Logger
syntax
Log-Receiver
syntax
Log-Level
syntax
Thread
syntax
Thread-Group
syntax
Subprocess
syntax
Place
syntax
Place-Channel
syntax
Semaphore
syntax
Will-Executor
syntax
Pseudo-Random-Generator
syntax
Path-String
syntax
(Pairof s t)
syntax
(Listof t)
syntax
(List t ...)
syntax
(List t ... trest ... bound)
syntax
(List* t t1 ... s)
syntax
(MListof t)
syntax
(MPairof t u)
syntax
(Boxof t)
syntax
(Vectorof t)
syntax
(Vector t ...)
syntax
FlVector
syntax
(HashTable k v)
syntax
(Setof t)
syntax
(Channelof t)
syntax
(Parameterof t)
(Parameterof s t)
syntax
(Promise t)
syntax
(Futureof t)
syntax
(Sequenceof t)
syntax
(Custodian-Boxof t)
syntax
(Thread-Cellof t)
syntax
(Ephemeronof t)
syntax
(Syntaxof t)
syntax
Identifier
syntax
Syntax
syntax
Syntax-E
syntax
(Sexpof t)
syntax
Sexp
syntax
Datum
syntax
(Prompt-Tagof s t)
syntax
(Continuation-Mark-Keyof t)
syntax
(dom ... -> rng)
(dom ... rest * -> rng)
(dom ... rest ... bound -> rng)
(dom -> rng : pred)
syntax
Procedure
syntax
(U t ...)
syntax
(case-> fun-ty ...)
syntax
(t t1 t2 ...)
syntax
(All (v ...) t)
syntax
(Values t ...)
syntax
v
syntax
(quote val)
syntax
i
syntax
(Rec n t)
syntax
(Struct st)
syntax
→
syntax
case→
syntax
∀
syntax
(Option t)
syntax
(Opaque t)
syntax
(let: ([v : t e] ...) . body)
(let: loop : t0 ([v : t e] ...) . body)
syntax
(plet: (a ...) ([v : t e] ...) . body)
syntax
(letrec: ([v : t e] ...) . body)
syntax
(let*: ([v : t e] ...) . body)
syntax
(let-values: ([([v : t] ...) e] ...) . body)
syntax
(letrec-values: ([([v : t] ...) e] ...) . body)
syntax
(let*-values: ([([v : t] ...) e] ...) . body)
syntax
(let/cc: v : t . body)
syntax
(let/ec: v : t . body)
syntax
(lambda: formals . body)
 
formals = ([v : t] ...)
        | ([v : t] ...    v : t *)
        | ([v : t] ...    v : t ...)
syntax
(λ: formals . body)
syntax
(plambda: (a ...) formals . body)
syntax
(case-lambda: [formals body] ...)
syntax
(pcase-lambda: (a ...) [formals body] ...)
syntax
(opt-lambda: formals . body)
 
formals = ([v : t] ... [v : t default] ...)
        | ([v : t] ... [v : t default] ...    v : t *)
        | ([v : t] ... [v : t default] ...    v : t ...)
syntax
(popt-lambda: (a ...) formals . body)
syntax
(for: type-ann-maybe (for:-clause ...)
  expr ...+)
 
type-ann-maybe = 
               | : u
                  
for:-clause    = [id : t seq-expr]
               | [id seq-expr]
               | #:when guard
syntax
(for/list: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/hash: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/hasheq: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/hasheqv: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/vector: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/flvector: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/and: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/or:   type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/first: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/last: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/sum: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/product: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/list: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/hash: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/hasheq: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/hasheqv: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/vector: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/flvector: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/and: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/or:   type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/first: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/last: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/sum: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for*/product: type-ann-maybe (for:-clause ...) expr ...+)
syntax
(for/lists: type-ann-maybe ([id : t] ...)
  (for:-clause ...)
  expr ...+)
syntax
(for/fold:  type-ann-maybe ([id : t init-expr] ...)
  (for:-clause ...)
  expr ...+)
syntax
(for*: void-ann-maybe (for-clause ...)
  expr ...+)
syntax
(for*/lists: type-ann-maybe ([id : t] ...)
  (for:-clause ...)
  expr ...+)
syntax
(for*/fold:  type-ann-maybe ([id : t init-expr] ...)
  (for:-clause ...)
  expr ...+)
syntax
for
syntax
for*
syntax
(do: : u ([id : t init-expr step-expr-maybe] ...)
         (stop?-expr finish-expr ...)
  expr ...+)
 
step-expr-maybe = 
                | step-expr
syntax
(define: v : t e)
(define: (f . formals) : t . body)
(define: (a ...) v : t e)
(define: (a ...) (f . formals) : t . body)
syntax
(struct: maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
name-spec       = name
                | name parent
                   
options         = #:transparent
                | #:mutable
syntax
(define-struct: maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
name-spec       = name
                | (name parent)
                   
options         = #:transparent
                | #:mutable
syntax
(define-struct/exec: name-spec ([f : t] ...) [e : proc-t])
 
name-spec = name
          | (name parent)
syntax
(define-type name t)
(define-type (name v ...) t)
syntax
(make-predicate t)
syntax
(define-predicate name t)
syntax
(: v t)
syntax
(provide: [v t] ...)
syntax
#{v : t}
syntax
(ann e t)
syntax
#{e :: t}
syntax
(cast e t)
syntax
(inst e t ...)
syntax
#{e @ t ...}
syntax
(require/typed m rt-clause ...)
 
rt-clause     = [r t]
              | [#:struct name ([f : t] ...)
                     struct-option ...]
              | [#:struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [#:opaque t pred]
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
syntax
(require/typed/provide m rt-clause ...)
syntax
with-handlers
syntax
lambda
syntax
λ
syntax
define
procedure
(default-continuation-prompt-tag)
 -> (-> (Prompt-Tagof Any (Any -> Any)))
syntax
(#%module-begin form ...)
syntax
(#%top-interaction . form)
procedure
(assert v) -> A
  v : (U #f A)
(assert v p?) -> B
  v : A
  p? : (A -> Any : B)
syntax
(with-asserts ([id maybe-pred] ...) body ...+)
 
maybe-pred = 
           | predicate
procedure
(defined? v) -> boolean?
  v : any/c
procedure
(index? v) -> boolean?
  v : any/c
syntax
(typecheck-fail orig-stx maybe-msg maybe-id)
 
maybe-msg = 
          | msg-string
             
maybe-id  = 
          | #:covered-id id
syntax
(:type t)
syntax
(:print-type e)
syntax
(:query-type/args f t ...)
syntax
(:query-type/result f t)
syntax
(with-type result-spec fv-clause body ...+)
(with-type export-spec fv-clause body ...+)
 
fv-clause   = 
            | #:freevars ([id fv-type] ...)
               
result-spec = #:result type
               
export-spec = ([export-id export-type] ...)
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(pred t)
syntax
Un
syntax
mu
syntax
Tuple
syntax
Parameter
syntax
Pair
syntax
values
syntax
(require/typed m rt-clause ...)
 
rt-clause     = [r t]
              | [struct name ([f : t] ...)
                     struct-option ...]
              | [struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [opaque t pred]
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
syntax
require-typed-struct
syntax
(Class args ...)
syntax
(Instance c)
syntax
(declare-refinement id)
syntax
(Refinement id)
syntax
(define-typed-struct/exec forms ...)
