9450
((3) 0 () 21 ((q lib "mzlib/etc.rkt") (q lib "mzlib/contract.rkt") (q lib "mzlib/list.rkt") (q lib "mzlib/pconvert.rkt") (q lib "mzlib/pregexp.rkt") (q lib "mzlib/compat.rkt") (q lib "mzlib/thread.rkt") (q lib "mzlib/cml.rkt") (q lib "mzlib/match.rkt") (q submod (lib "racket/unit.rkt") compat) (q lib "mzlib/file.rkt") (q lib "mzlib/string.rkt") (q lib "mzlib/transcr.rkt") (q lib "mzlib/awk.rkt") (q lib "mzlib/class100.rkt") (q lib "mzlib/include.rkt") (q lib "mzlib/pconvert-prop.rkt") (q lib "mzlib/kw.rkt") (q lib "mzlib/os.rkt") (q lib "mzlib/struct.rkt") (q lib "mzlib/serialize.rkt")) () (h ! (equal) ((c form c (c (? . 20) q define-serializable-struct)) q (22733 . 2)) ((c form c (c (? . 1) q define/contract)) q (6218 . 2)) ((c def c (c (? . 2) q fourth)) q (13169 . 3)) ((c form c (c (? . 14) q class100*-asi)) q (3449 . 2)) ((c form c (c (? . 0) q evcase)) q (8823 . 3)) ((c form c (c (? . 0) q define-syntax-set)) q (8774 . 2)) ((c form c (c (? . 1) q ->pp)) q (7627 . 11)) ((c def c (c (? . 3) q get-shared)) q (16831 . 5)) ((c def c (c (? . 16) q prop:print-convert-constructor-name)) q (17923 . 2)) ((c def c (c (? . 2) q third)) q (13106 . 3)) ((c def c (c (? . 0) q namespace-defined?)) q (9465 . 3)) ((c form c (c (? . 1) q ->)) q (6667 . 3)) ((c def c (c (? . 18) q gethostname)) q (14730 . 2)) ((c def c (c (? . 4) q pregexp-match-positions)) q (19071 . 15)) ((c def c (c (? . 11) q read-from-string)) q (24324 . 6)) ((c def c (c (? . 10) q build-relative-path)) q (10614 . 7)) ((c def c (c (? . 2) q second)) q (13042 . 3)) ((c def c (c (? . 12) q transcript-off)) q (26316 . 2)) ((c def c (c (? . 3) q print-convert)) q (17032 . 4)) ((c def c (c (? . 3) q install-converting-printer)) q (16982 . 2)) ((c def c (c (? . 2) q quicksort)) q (13856 . 4)) ((q form ((lib "mzlib/plt-match.rkt") define-match-expander)) q (18150 . 4)) ((c def c (c (? . 5) q 1+)) q (5001 . 3)) ((q def ((lib "mzlib/port.rkt") strip-shell-command-start)) q (18307 . 3)) ((c form c (c (? . 9) q struct)) q (26352 . 7)) ((c form c (c (? . 0) q hash-table)) q (9922 . 2)) ((c def c (c (? . 2) q mergesort)) q (13739 . 4)) ((c def c (c (? . 4) q pregexp-replace*)) q (20553 . 7)) ((c def c (c (? . 7) q time-evt)) q (4675 . 3)) ((c form c (c (? . 1) q ->d)) q (7225 . 2)) ((c form c (c (? . 8) q match-define)) q (14367 . 2)) ((c def c (c (? . 6) q consumer-thread)) q (25219 . 4)) ((c form c (c (? . 1) q ->pp-rest)) q (7988 . 13)) ((c def c (c (? . 5) q <?)) q (4783 . 3)) ((c def c (c (? . 6) q run-server)) q (25336 . 21)) ((c def c (c (? . 13) q match:substring)) q (1511 . 4)) ((c def c (c (? . 7) q thread-done-evt)) q (4577 . 3)) ((c form c (c (? . 8) q match-lambda*)) q (14174 . 2)) ((c form c (c (? . 5) q define-structure)) q (5368 . 4)) ((c def c (c (? . 3) q whole/fractional-exact-numbers)) q (17569 . 4)) ((q def ((lib "mzlib/math.rkt") e)) q (14712 . 2)) ((c form c (c (? . 15) q include-at/relative-to/reader)) q (11571 . 2)) ((q form ((lib "mzlib/cmdline.rkt") command-line)) q (3561 . 21)) ((c form c (c (? . 8) q match)) q (13973 . 5)) ((c form c (c (? . 9) q struct/ctc)) q (26506 . 7)) ((c def c (c (? . 1) q build-flat-contract)) q (6542 . 4)) ((c def c (c (? . 10) q call-with-input-file*)) q (9989 . 5)) ((c def c (c (? . 5) q putprop)) q (5666 . 5)) ((c form c (c (? . 0) q begin-with-definitions)) q (8723 . 2)) ((c form c (c (? . 19) q make-->vector)) q (25185 . 2)) ((c def c (c (? . 11) q expr->string)) q (24261 . 3)) ((c form c (c (? . 9) q struct~s)) q (26717 . 2)) ((c def c (c (? . 2) q merge-sorted-lists)) q (13587 . 5)) ((c form c (c (? . 0) q opt-lambda)) q (9584 . 2)) ((c form c (c (? . 9) q struct~r)) q (26681 . 2)) ((q def ((lib "mzlib/sandbox.rkt") make-evaluator)) q (21228 . 15)) ((c def c (c (? . 12) q transcript-on)) q (26248 . 3)) ((c def c (c (? . 7) q current-time)) q (4639 . 2)) ((c def c (c (? . 5) q 1-)) q (5050 . 3)) ((c def c (c (? . 13) q regexp-exec)) q (1630 . 4)) ((c def c (c (? . 10) q build-absolute-path)) q (10910 . 8)) ((c def c (c (? . 3) q add-make-prefix-to-constructor)) q (15503 . 4)) ((c def c (c (? . 4) q pregexp-replace)) q (20234 . 7)) ((c form c (c (? . 14) q class100*)) q (1742 . 36)) ((c form c (c (? . 8) q define-match-expander)) q (14400 . 4)) ((c def c (c (? . 3) q quasi-read-style-printing)) q (17363 . 4)) ((c def c (c (? . 7) q channel)) q (4398 . 2)) ((c def c (c (? . 3) q constructor-style-printing)) q (15696 . 4)) ((c def c (c (? . 3) q abbreviate-cons-as-list)) q (14935 . 4)) ((c def c (c (? . 7) q channel-send-evt)) q (4495 . 4)) ((c def c (c (? . 5) q >?)) q (4837 . 3)) ((q def ((lib "mzlib/restart.rkt") restart-mzscheme)) q (20873 . 9)) ((c form c (c (? . 8) q define/match)) q (14083 . 2)) ((c def c (c (? . 2) q first)) q (12994 . 3)) ((c form c (c (? . 0) q recur)) q (9625 . 2)) ((c def c (c (? . 5) q getprop)) q (5535 . 5)) ((c def c (c (? . 5) q atom?)) q (5322 . 3)) ((c def c (c (? . 0) q identity)) q (8963 . 3)) ((c form c (c (? . 0) q this-expression-source-directory)) q (9768 . 3)) ((c def c (c (? . 8) q match-equality-test)) q (14557 . 4)) ((c form c (c (? . 14) q super-init)) q (3521 . 2)) ((c form c (c (? . 9) q struct~r/ctc)) q (26697 . 2)) ((c def c (c (? . 5) q gentmp)) q (5099 . 3)) ((c def c (c (? . 0) q loop-until)) q (9286 . 6)) ((c def c (c (? . 5) q real-time)) q (5280 . 2)) ((c form c (c (? . 1) q ->d*)) q (7285 . 3)) ((c form c (c (? . 15) q include-at/relative-to)) q (11511 . 2)) ((c def c (c (? . 3) q named/undefined-handler)) q (15346 . 4)) ((c def c (c (? . 3) q booleans-as-true/false)) q (15061 . 4)) ((c def c (c (? . 3) q build-share)) q (15643 . 3)) ((c def c (c (? . 16) q print-convert-named-constructor?)) q (17979 . 3)) ((c def c (c (? . 11) q glob->regexp)) q (23430 . 10)) ((c def c (c (? . 7) q spawn)) q (4336 . 3)) ((c form c (c (? . 15) q include/reader)) q (11651 . 2)) ((c form c (c (? . 17) q define/kw)) q (11742 . 32)) ((c form c (c (? . 1) q case->)) q (8560 . 2)) ((c def c (c (? . 17) q keyword-get)) q (12843 . 5)) ((c def c (c (? . 16) q print-converter-proc)) q (17807 . 4)) ((q def ((lib "mzlib/sendevent.rkt") send-event)) q (22023 . 14)) ((c def c (c (? . 1) q vector/c)) q (6414 . 3)) ((c form c (c (? . 14) q class100-asi)) q (3390 . 2)) ((c def c (c (? . 2) q last-pair)) q (13535 . 3)) ((c form c (c (? . 8) q match-letrec)) q (14313 . 2)) ((c form c (c (? . 8) q match-let*)) q (14261 . 2)) ((c def c (c (? . 4) q pregexp-match)) q (18383 . 15)) ((c form c (c (? . 0) q begin-lifted)) q (8689 . 2)) ((c def c (c (? . 11) q read-from-string-all)) q (24567 . 6)) ((c form c (c (? . 0) q nor)) q (9560 . 2)) ((c def c (c (? . 5) q =?)) q (4727 . 3)) ((c def c (c (? . 13) q match:start)) q (1245 . 4)) ((c form c (c (? . 9) q struct~s/ctc)) q (26733 . 2)) ((c def c (c (? . 2) q sixth)) q (13296 . 3)) ((c form c (c (? . 17) q lambda/kw)) q (11699 . 2)) ((c def c (c (? . 13) q match:end)) q (1379 . 4)) ((c def c (c (? . 5) q flush-output-port)) q (5185 . 3)) ((c form c (c (? . 0) q let+)) q (9014 . 11)) ((c def c (c (? . 1) q vectorof)) q (6345 . 3)) ((c def c (c (? . 3) q show-sharing)) q (17477 . 4)) ((c form c (c (? . 14) q class100)) q (3309 . 4)) ((c def c (c (? . 3) q current-read-eval-convert-print-prompt)) q (16690 . 4)) ((c form c (c (? . 1) q opt->*)) q (7067 . 3)) ((c def c (c (? . 11) q string-uppercase!)) q (23927 . 3)) ((c def c (c (? . 1) q box/c)) q (6279 . 3)) ((c def c (c (? . 2) q fifth)) q (13233 . 3)) ((c def c (c (? . 16) q print-convert-constructor-name)) q (18052 . 3)) ((c form c (c (? . 0) q this-expression-file-name)) q (9852 . 3)) ((c form c (c (? . 15) q include)) q (11283 . 10)) ((c def c (c (? . 3) q current-build-share-name-hook)) q (16117 . 5)) ((c def c (c (? . 16) q prop:print-converter)) q (17709 . 2)) ((c def c (c (? . 2) q eighth)) q (13424 . 3)) ((c def c (c (? . 18) q truncate-file)) q (14806 . 4)) ((c def c (c (? . 16) q print-converter?)) q (17750 . 3)) ((c def c (c (? . 11) q string-lowercase!)) q (23831 . 3)) ((c def c (c (? . 4) q pregexp-split)) q (19815 . 9)) ((c form c (c (? . 1) q ->*)) q (6756 . 6)) ((c form c (c (? . 8) q match-lambda)) q (14139 . 2)) ((q def ((lib "mzlib/compile.rkt") compile-file)) q (5879 . 8)) ((c form c (c (? . 19) q copy-struct)) q (24814 . 3)) ((c def c (c (? . 5) q <=?)) q (4891 . 3)) ((c def c (c (? . 11) q eval-string)) q (24023 . 6)) ((c def c (c (? . 10) q call-with-output-file*)) q (10166 . 11)) ((c def c (c (? . 2) q rest)) q (13488 . 3)) ((c def c (c (? . 3) q print-convert-expr)) q (17150 . 7)) ((c def c (c (? . 3) q current-print-convert-hook)) q (16311 . 8)) ((c def c (c (? . 3) q use-named/undefined-handler)) q (15181 . 4)) ((c def c (c (? . 3) q current-build-share-hook)) q (15840 . 7)) ((c form c (c (? . 0) q rec)) q (9666 . 4)) ((c form c (c (? . 1) q struct/c)) q (6488 . 2)) ((c def c (c (? . 2) q seventh)) q (13359 . 3)) ((c form c (c (? . 19) q define-struct/properties)) q (24916 . 7)) ((c def c (c (? . 18) q getpid)) q (14767 . 2)) ((c def c (c (? . 5) q >=?)) q (4946 . 3)) ((c form c (c (? . 8) q match-let)) q (14210 . 2)) ((c form c (c (? . 0) q nand)) q (9535 . 2)) ((c form c (c (? . 1) q opt->)) q (6918 . 3)) ((c form c (c (? . 1) q object-contract)) q (8617 . 2)) ((c form c (c (? . 20) q define-serializable-struct/versions)) q (22824 . 13)) ((c def c (c (? . 7) q channel-recv-evt)) q (4432 . 3)) ((c form c (c (? . 1) q ->r)) q (7424 . 7)) ((c form c (c (? . 13) q awk)) q (0 . 38)) ((c def c (c (? . 5) q new-cafe)) q (5784 . 3))))
syntax
(awk next-record-expr
     (record field-id ...)
     maybe-counter
     ((state-variable init-expr) ...)
     maybe-continue
  clause ...)
 
maybe-counter   = 
                | id
                   
maybe-continue  = 
                | id
                   
clause          = (test body ...+)
                | (test => procedure-expr)
                | (/ regexp-str / (id-or-false ...+) body ...+)
                | (range excl-start-test excl-stop-test body ...+)
                | (:range incl-start-test excl-stop-test body ...+)
                | (range: excl-start-test incl-stop-test body ...+)
                | (:range: incl-start-test incl-stop-test body ...+)
                | (else body ...+)
                | (after body ...+)
                   
test            = integer
                | regexp-string
                | expr
                   
excl-start-test = test
                   
excl-stop-test  = test
                   
incl-start-test = test
                   
incl-stop-test  = test
                   
id-or-false     = id
                | #f
procedure
(match:start rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:end rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:substring rec [which]) -> string?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(regexp-exec re s) -> (or/c .... false/c)
  re : (or/c string? regexp?)
  s : string?
syntax
(class100* superclass-expr (interface-expr ...) init-ids
  class100-clause
  ...)
 
init-ids            = id
                    | (id ... id-with-default ...)
                    | (id ... id-with-default ... . id)
                       
id-with-default     = (id default-expr)
                       
class100-clause     = (sequence expr ...)
                    | (public public-method-decl ...)
                    | (override public-method-decl ...)
                    | (augment public-method-decl ...)
                    | (pubment public-method-decl ...)
                    | (overment public-method-decl ...)
                    | (augride public-method-decl ...)
                    | (private private-method-decl ...)
                    | (private-field private-var-decl ...)
                    | (inherit inherit-method-decl ...)
                    | (rename rename-method-decl ...)
                       
public-method-decl  = ((internal-id external-id) method-procedure)
                    | (id method-procedure)
                       
private-method-decl = (id method-procedure)
                       
private-var-decl    = (id initial-value-expr)
                    | (id)
                    | id
                       
inherit-method-decl = id
                    | (internal-instance-id external-inherited-id)
                       
rename-method-decl  = (internal-id external-id)
syntax
(class100 superclass-expr init-ids
    class100-clause
    ...)
syntax
(class100-asi superclass instance-id-clause ...)
syntax
(class100*-asi superclass interfaces instance-id-clause ...)
syntax
(super-init init-arg-expr ...)
syntax
(command-line program-name-expr argv-expr clause ...)
 
clause      = (multi flag-spec ...)
            | (once-each flag-spec ...)
            | (once-any flag-spec ...)
            | (final flag-spec ...)
            | (help-labels string ...)
            | (args arg-formals body-expr ...+)
            | (=> finish-proc-expr arg-help-expr help-proc-expr
                  unknown-proc-expr)
               
flag-spec   = (flags id ... help-str ...+ body-expr ...+)
            | (flags => handler-expr help-expr)
               
flags       = flag-string
            | (flag-string ...+)
               
arg-formals = id
            | (id ...)
            | (id ...+ . id)
procedure
(spawn thunk) -> thread?
  thunk : (-> any)
procedure
(channel) -> channel?
procedure
(channel-recv-evt ch) -> evt?
  ch : channel?
procedure
(channel-send-evt ch v) -> evt?
  ch : channel?
  v : any/c
procedure
(thread-done-evt thd) -> any
  thd : thread?
procedure
(current-time) -> real?
procedure
(time-evt tm) -> evt?
  tm : real?
procedure
(=? n ...+) -> boolean?
  n : number?
procedure
(<? n ...+) -> boolean?
  n : real?
procedure
(>? n ...+) -> boolean?
  n : real?
procedure
(<=? n ...+) -> boolean?
  n : real?
procedure
(>=? n ...+) -> boolean?
  n : real?
procedure
(1+ n) -> number?
  n : number?
procedure
(1- n) -> number?
  n : number?
procedure
(gentmp [base]) -> symbol?
  base : (or/c string? symbol?) = "g"
procedure
(flush-output-port [o]) -> void?
  o : output-port? = (current-output-port)
procedure
(real-time) -> exact-integer?
procedure
(atom? v) -> any
  v : any/c
syntax
(define-structure (name-id field-id ...))
(define-structure (name-id field-id ...)
                  ((init-field-id init-expr) ...))
procedure
(getprop sym property [default]) -> any/c
  sym : symbol?
  property : symbol?
  default : any/c = #f
procedure
(putprop sym property value) -> void?
  sym : symbol?
  property : symbol?
  value : any/c
procedure
(new-cafe [eval-handler]) -> any
  eval-handler : (any/c . -> . any) = #f
procedure
(compile-file src [dest filter]) -> path?
  src : path-string?
  dest : path-string?
       = (let-values ([(base name dir?) (split-path src)])
           (build-path base "compiled"
                       (path-add-suffix name #".zo")))
  filter : (any/c . -> . any/c) = values
syntax
(define/contract id contract-expr init-value-expr)
procedure
(box/c c) -> flat-contract?
  c : flat-contract?
procedure
(vectorof c) -> flat-contract?
  c : flat-contract?
procedure
(vector/c c ...) -> flat-contract?
  c : flat-contract?
syntax
(struct/c struct-id flat-contract-expr ...)
procedure
(build-flat-contract name predicate) -> flat-contract?
  name : symbol?
  predicate : (-> any/c any)
syntax
(-> contract-dom-expr ... any)
(-> contract-dom-expr ... contract-rng-expr)
syntax
(->* (contract-dom-expr ...) ->*rng)
(->* (contract-dom-expr ...) contract-rest-expr ->*rng)
 
->*rng = (contract-rng-expr ...)
       | any
syntax
(opt-> (contract-req-expr ...) (contact-opt-expr ...) any)
(opt-> (contract-req-expr ...) (contact-opt-expr ...) contract-rng-expr)
syntax
(opt->* (contract-req-expr ...) (contact-opt-expr ...) any)
(opt->* (contract-req-expr ...) (contact-opt-expr ...) (contract-rng-expr ...))
syntax
(->d contract-dom-expr ... contract-rng-fun-expr)
syntax
(->d* (contract-dom-expr ...) contract-rng-fun-expr)
(->d* (contract-dom-expr ...) contract-rest-expr contract-rng-fun-expr)
syntax
(->r ([dom-x contract-dom-expr] ...) rng)
(->r ([dom-x contract-dom-expr] ...) rest-x contract-rest-expr rng)
 
rng = any
    | (values contract-expr ...)
    | contract-expr
syntax
(->pp ([dom-x contract-dom-expr] ...) pre-cond-expr any)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      (values [rng-x contract-rng-expr] ...)
      post-cond-expr)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      contract-rng-expr
      rng-x
      post-cond-expr)
syntax
(->pp-rest ([dom-x contract-dom-expr] ...) rest-x rest-contract-expr pre-cond-expr any)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           (values [rng-x contract-rng-expr] ...)
           post-cond-expr)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           contract-rng-expr
           rng-x
           post-cond-expr)
syntax
(case-> mzlib/contract-arrow-contract-expr ...)
syntax
(object-contract [id mzlib/contract-arrow-contract-expr] ...)
syntax
(begin-lifted expr ...+)
syntax
(begin-with-definitions defn-or-expr ...)
syntax
(define-syntax-set (id ...) defn ...)
syntax
(evcase key-expr (value-expr body-expr ...) ...+)
(evcase key-expr (value-expr body-expr ...) ... [else body-expr ...])
procedure
(identity v) -> any/c
  v : any/c
syntax
(let+ clause body-expr ...+)
 
clause = (val target expr)
       | (rec target expr)
       | (vals (target ...) expr)
       | (recs (target expr) ...)
       | (_ expr ...)
          
target = id
       | (values id ...)
procedure
(loop-until start done? next f) -> void?
  start : any/c
  done? : (any/c . -> . any)
  next : (any/c . -> . any/c)
  f : (any/c . -> . any)
procedure
(namespace-defined? sym) -> boolean?
  sym : symbol?
syntax
(nand expr ...)
syntax
(nor expr ...)
syntax
(opt-lambda formals body ...+)
syntax
(recur id bindings body ...+)
syntax
(rec id value-expr)
(rec (id arg-id ...) expr)
(rec (id arg-id ... . rest-id) expr)
syntax
(this-expression-source-directory)
(this-expression-source-directory datum)
syntax
(this-expression-file-name)
(this-expression-file-name datum)
syntax
(hash-table (quote flag) ... (key-expr val-expr) ...)
procedure
(call-with-input-file* file proc [mode]) -> any
  file : path-string?
  proc : (input-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
procedure
(call-with-output-file*  file         
                         proc         
                        [mode         
                         exists]) -> any
  file : path-string?
  proc : (output-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
  exists : (one-of/c 'error 'append 'update
                     'replace 'truncate 'truncate/replace)
         = 'error
procedure
(build-relative-path base sub ...) -> (and/c path? relative-path?)
  base : (or/c path-string?
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     relative-path?)
              (one-of/c 'up 'same))
procedure
(build-absolute-path base sub ...) -> (and/c path? absolute-path?)
  base : (or/c (and/c path-string?
                      (not/c relative-path?))
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     (not/c complete-path?))
              (one-of/c 'up 'same))
syntax
(include path-spec)
 
path-spec = string
          | (build-path elem ...+)
          | (lib file-string collection-string ...)
             
elem      = string
          | up
          | same
syntax
(include-at/relative-to context source path-spec)
syntax
(include-at/relative-to/reader context source path-spec reader-expr)
syntax
(include/reader path-spec reader-expr)
syntax
(lambda/kw kw-formals body ...+)
syntax
(define/kw (head args) body ...+)
 
kw-formals     = id
               | (id ... [#:optional optional-spec ...]
                         [#:key key-spec ...]
                         [rest/mode-spec ...])
               | (id ... . id)
                  
optional-spec  = id
               | (id default-expr)
                  
key-spec       = id
               | (id default-expr)
               | (id keyword default-expr)
                  
rest/mode-spec = #:rest id
               | #:other-keys id
               | #:other-keys+body id
               | #:all-keys id
               | #:body kw-formals
               | #:allow-other-keys
               | #:forbid-other-keys
               | #:allow-duplicate-keys
               | #:forbid-duplicate-keys
               | #:allow-body
               | #:forbid-body
               | #:allow-anything
               | #:forbid-anything
                  
head           = id
               | (head . kw-formals)
procedure
(keyword-get args kw not-found) -> any
  args : (listof (cons/c keyword? any/c))
  kw : keyword?
  not-found : (-> any)
procedure
(first v) -> any/c
  v : pair?
procedure
(second v) -> any/c
  v : (and/c pair? ....)
procedure
(third v) -> any/c
  v : (and/c pair? ....)
procedure
(fourth v) -> any/c
  v : (and/c pair? ....)
procedure
(fifth v) -> any/c
  v : (and/c pair? ....)
procedure
(sixth v) -> any/c
  v : (and/c pair? ....)
procedure
(seventh v) -> any/c
  v : (and/c pair? ....)
procedure
(eighth v) -> any/c
  v : (and/c pair? ....)
procedure
(rest v) -> any/c
  v : pair?
procedure
(last-pair v) -> pair?
  v : pair?
procedure
(merge-sorted-lists lst1 lst2 less-than?) -> list?
  lst1 : list?
  lst2 : lst?
  less-than? : (any/c any/c . -> . any/c)
procedure
(mergesort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
procedure
(quicksort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
syntax
(match val-expr clause ...)
 
clause = [pat expr ...+]
       | [pat (=> id) expr ...+]
syntax
(define/match (head args) match*-clause ...)
syntax
(match-lambda clause ...)
syntax
(match-lambda* clause ...)
syntax
(match-let ([pat expr] ...) body ...+)
syntax
(match-let* ([pat expr] ...) body ...+)
syntax
(match-letrec ([pat expr] ...) body ...+)
syntax
(match-define pat expr)
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
parameter
(match-equality-test) -> (any/c any/c . -> . any)
(match-equality-test comp-proc) -> void?
  comp-proc : (any/c any/c . -> . any)
value
e : real?
procedure
(gethostname) -> string?
procedure
(getpid) -> exact-integer?
procedure
(truncate-file file [n-bytes]) -> void?
  file : path-string?
  n-bytes : exact-nonnegative-integer? = 0
parameter
(abbreviate-cons-as-list) -> boolean?
(abbreviate-cons-as-list abbreviate?) -> void?
  abbreviate? : any/c
parameter
(booleans-as-true/false) -> boolean?
(booleans-as-true/false use-name?) -> void?
  use-name? : any/c
parameter
(use-named/undefined-handler) -> (any/c . -> . any/c)
(use-named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(named/undefined-handler) -> (any/c . -> . any/c)
(named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(add-make-prefix-to-constructor) -> boolean?
(add-make-prefix-to-constructor add-prefix?) -> void?
  add-prefix? : any/c
procedure
(build-share v) -> ....
  v : any/c
parameter
(constructor-style-printing) -> boolean?
(constructor-style-printing use-constructors?) -> void?
  use-constructors? : any/c
parameter
(current-build-share-hook)
 -> (any/c (any/c . -> . void?)
           (any/c . -> . void?) . -> . any)
(current-build-share-hook hook) -> void?
  hook : (any/c (any/c . -> . void?)
                (any/c . -> . void?) . -> . any)
parameter
(current-build-share-name-hook)
 -> (any/c . -> . (or/c symbol? false/c))
(current-build-share-name-hook hook) -> void?
  hook : (any/c . -> . (or/c symbol? false/c))
parameter
(current-print-convert-hook) -> (any/c (any/c . -> . any/c)
                                       (any/c . -> . any/c)
                                       . -> . any/c)
(current-print-convert-hook hook) -> void?
  hook : (any/c (any/c . -> . any/c)
                (any/c . -> . any/c)
                . -> . any/c)
parameter
(current-read-eval-convert-print-prompt) -> string?
(current-read-eval-convert-print-prompt str) -> void?
  str : string?
procedure
(get-shared share-info [cycles-only?])
 -> (list-of (cons/c symbol? any/c))
  share-info : ....
  cycles-only? : any/c = #f
procedure
(install-converting-printer) -> void?
procedure
(print-convert v [cycles-only?]) -> any/c
  v : any/c
  cycles-only? : any/c = (show-sharing)
procedure
(print-convert-expr share-info        
                    v                 
                    unroll-once?) -> any/c
  share-info : ....
  v : any/c
  unroll-once? : any/c
parameter
(quasi-read-style-printing) -> boolean?
(quasi-read-style-printing on?) -> void?
  on? : any/c
parameter
(show-sharing) -> boolean?
(show-sharing show?) -> void?
  show? : any/c
parameter
(whole/fractional-exact-numbers) -> boolean?
(whole/fractional-exact-numbers whole-frac?) -> void?
  whole-frac? : any/c
value
prop:print-converter : property?
procedure
(print-converter? v) -> any
  v : any/c
procedure
(print-converter-proc v)
 -> (any/c (any/c . -> . any/c) . -> . any/c)
  v : print-converter?
value
prop:print-convert-constructor-name : property?
procedure
(print-convert-named-constructor? v) -> any
  v : any/c
procedure
(print-convert-constructor-name v) -> any
  v : print-convert-named-constructor?
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
procedure
(strip-shell-command-start in) -> void?
  in : input-port?
procedure
(pregexp-match  pattern       
                input         
               [start-pos     
                end-pos       
                output-port]) 
 -> (or/c (listof (or/c (cons (or/c string? bytes?)
                              (or/c string? bytes?))
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-match-positions  pattern       
                          input         
                         [start-pos     
                          end-pos       
                          output-port]) 
 -> (or/c (listof (or/c (cons exact-nonnegative-integer?
                              exact-nonnegative-integer?)
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-split  pattern       
                input         
               [start-pos     
                end-pos]) -> (listof (or/c string? bytes?))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
procedure
(pregexp-replace pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(pregexp-replace* pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(restart-mzscheme init-argv             
                  adjust-flag-table     
                  argv                  
                  init-namespace)   -> boolean?
  init-argv : (vectorof string?)
  adjust-flag-table : (any/c . -> . any/c)
  argv : (vectorof string?)
  init-namespace : (-> any)
procedure
(make-evaluator language               
                requires               
                input-program ...) -> (any/c . -> . any)
  language : (or/c module-path?
                   (one-of/c 'r5rs 'beginner 'beginner-abbr
                             'intermediate 'intermediate-lambda 'advanced)
                   (list/c (one-of/c 'special) symbol?)
                   (list/c (one-of/c 'special) symbol?)
                   (cons/c (one-of/c 'begin) list?))
  requires : (or/c (cons/c 'begin list?)
                   (listof (or/c module-path? path?)))
  input-program : any/c
(make-evaluator module-decl) -> (any/c . -> . any)
  module-decl : (or/c syntax? pair?)
procedure
(send-event  receiver-bytes        
             event-class-bytes     
             event-id-bytes        
            [direct-arg-v          
             argument-list])   -> any/c
  receiver-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  event-class-bytes : (lambda (s) (and (bytes? s)
                                       (= 4 (bytes-length s))))
  event-id-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  direct-arg-v : any/c = (void)
  argument-list : list? = null
syntax
(define-serializable-struct id-maybe-super (field-id ...) maybe-inspector-expr)
syntax
(define-serializable-struct/versions id-maybe-super vers-num (field-id ...)
                                     (other-version-clause ...)
                                     maybe-inspector-expr)
 
id-maybe-super       = id
                     | (id super-id)
                        
maybe-inspector-expr = 
                     | inspector-expr
                        
other-version-clause = (other-vers make-proc-expr
                                   cycle-make-proc-expr)
procedure
(glob->regexp [str                 
               hide-dots?          
               case-sensitive?     
               simple?])       -> (or/c regexp? byte-regexp?)
  str : (or/c string bytes?) = ?
  hide-dots? : any/c = #t
  case-sensitive? : any/c
                  = (eq? (system-path-convention-type)'unix)
  simple? : any/c = #f
procedure
(string-lowercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(string-uppercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(eval-string str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(expr->string expr) -> string?
  expr : any/c
procedure
(read-from-string str [err-handler]) -> any/c
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(read-from-string-all str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
syntax
(copy-struct struct-id struct-expr
             (accessor-id field-expr) ...)
syntax
(define-struct/properties id (field-id ...)
                          ((prop-expr val-expr) ...)
                          maybe-inspector-expr)
 
maybe-inspector-expr = 
                     | expr
syntax
(make-->vector struct-id)
procedure
(consumer-thread f [init]) -> thread? procedure?
  f : procedure?
  init : (-> any) = void
procedure
(run-server  port-no            
             conn-proc          
             conn-timeout       
            [handler            
             listen             
             close              
             accept             
             accept/break]) -> void?
  port-no : (integer-in 1 65535)
  conn-proc : (input-port? output-port? . -> . any)
  conn-timeout : (and/c real? (not/c negative?))
  handler : (exn? . -> . any/c) = void
  listen : ((integer-in 1 65535) (one-of/c 5) (one-of/c #t)
            . -> . listener?)
         = tcp-listen
  close : (listener? . -> . any) = tcp-close
  accept : (listener? . ->* . (input-port? output-port?))
         = tcp-accept
  accept/break : (listener? . ->* . (input-port? output-port?))
               = tcp-accept/enable-break
procedure
(transcript-on filename) -> any
  filename : any/c
procedure
(transcript-off) -> any
syntax
(struct id (field-id ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
(struct/ctc id ([field-id contract-expr] ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
struct~r
syntax
struct~r/ctc
syntax
struct~s
syntax
struct~s/ctc
