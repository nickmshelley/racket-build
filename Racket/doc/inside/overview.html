<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><title>1&nbsp;Overview</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Inside:<span class="mywbr"> </span> Racket C API</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="im_values_types.html" class="tocviewlink" data-pltdoc="x">Values and Types</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="im_memoryalloc.html" class="tocviewlink" data-pltdoc="x">Memory Allocation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="im_env.html" class="tocviewlink" data-pltdoc="x">Namespaces and Modules</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Procedures.html" class="tocviewlink" data-pltdoc="x">Procedures</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Evaluation.html" class="tocviewlink" data-pltdoc="x">Evaluation</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="exceptions.html" class="tocviewlink" data-pltdoc="x">Exceptions and Escape Continuations</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="threads.html" class="tocviewlink" data-pltdoc="x">Threads</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="config.html" class="tocviewlink" data-pltdoc="x">Parameterizations</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="contmarks.html" class="tocviewlink" data-pltdoc="x">Continuation Marks</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="im_encodings.html" class="tocviewlink" data-pltdoc="x">String Encodings</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Bignums__Rationals__and_Complex_Numbers.html" class="tocviewlink" data-pltdoc="x">Bignums, Rationals, and Complex Numbers</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Ports_and_the_Filesystem.html" class="tocviewlink" data-pltdoc="x">Ports and the Filesystem</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Structures.html" class="tocviewlink" data-pltdoc="x">Structures</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="security.html" class="tocviewlink" data-pltdoc="x">Security Guards</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Custodians.html" class="tocviewlink" data-pltdoc="x">Custodians</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Subprocesses.html" class="tocviewlink" data-pltdoc="x">Subprocesses</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Miscellaneous_Utilities.html" class="tocviewlink" data-pltdoc="x">Miscellaneous Utilities</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="Flags_and_Hooks.html" class="tocviewlink" data-pltdoc="x">Flags and Hooks</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" data-pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Overview</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part.__.Scheme__versus__.Racket_%29" class="tocviewlink" data-pltdoc="x">&ldquo;Scheme&rdquo; versus &ldquo;Racket&rdquo;</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._.Building_.Racket_from_.Source%29" class="tocviewlink" data-pltdoc="x">Building Racket from Source</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part._.C.G.C_versus_3m%29" class="tocviewlink" data-pltdoc="x">CGC versus 3m</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#%28part._.Writing_.Racket_.Extensions%29" class="tocviewlink" data-pltdoc="x">Writing Racket Extensions</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="#%28part._embedding%29" class="tocviewlink" data-pltdoc="x">Embedding Racket into a Program</a></td></tr><tr><td align="right">1.6&nbsp;</td><td><a href="#%28part._places%29" class="tocviewlink" data-pltdoc="x">Racket and Places</a></td></tr><tr><td align="right">1.7&nbsp;</td><td><a href="#%28part._.Racket_and_.Threads%29" class="tocviewlink" data-pltdoc="x">Racket and Threads</a></td></tr><tr><td align="right">1.8&nbsp;</td><td><a href="#%28part._im~3aunicode%29" class="tocviewlink" data-pltdoc="x">Racket, Unicode, Characters, and Strings</a></td></tr><tr><td align="right">1.9&nbsp;</td><td><a href="#%28part._im~3aintsize%29" class="tocviewlink" data-pltdoc="x">Integers</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#(part.__.Scheme__versus__.Racket_)" class="tocsubseclink" data-pltdoc="x">&ldquo;Scheme&rdquo; versus &ldquo;Racket&rdquo;</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#(part._.Building_.Racket_from_.Source)" class="tocsubseclink" data-pltdoc="x">Building Racket from Source</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#(part._.C.G.C_versus_3m)" class="tocsubseclink" data-pltdoc="x">CGC versus 3m</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#(part._.Writing_.Racket_.Extensions)" class="tocsubseclink" data-pltdoc="x">Writing Racket Extensions</a></td></tr><tr><td><span class="tocsublinknumber">1.4.1<tt>&nbsp;</tt></span><a href="#(part._.C.G.C_.Extensions)" class="tocsubseclink" data-pltdoc="x">CGC Extensions</a></td></tr><tr><td><span class="tocsublinknumber">1.4.2<tt>&nbsp;</tt></span><a href="#(part._3m_.Extensions)" class="tocsubseclink" data-pltdoc="x">3m Extensions</a></td></tr><tr><td><span class="tocsublinknumber">1.4.3<tt>&nbsp;</tt></span><a href="#(part._.Declaring_a_.Module_in_an_.Extension)" class="tocsubseclink" data-pltdoc="x">Declaring a Module in an Extension</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#(part._embedding)" class="tocsubseclink" data-pltdoc="x">Embedding Racket into a Program</a></td></tr><tr><td><span class="tocsublinknumber">1.5.1<tt>&nbsp;</tt></span><a href="#(part._.C.G.C_.Embedding)" class="tocsubseclink" data-pltdoc="x">CGC Embedding</a></td></tr><tr><td><span class="tocsublinknumber">1.5.2<tt>&nbsp;</tt></span><a href="#(part._3m_.Embedding)" class="tocsubseclink" data-pltdoc="x">3m Embedding</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#(part._places)" class="tocsubseclink" data-pltdoc="x">Racket and Places</a></td></tr><tr><td><span class="tocsublinknumber">1.7<tt>&nbsp;</tt></span><a href="#(part._.Racket_and_.Threads)" class="tocsubseclink" data-pltdoc="x">Racket and Threads</a></td></tr><tr><td><span class="tocsublinknumber">1.8<tt>&nbsp;</tt></span><a href="#(part._im~3aunicode)" class="tocsubseclink" data-pltdoc="x">Racket, Unicode, Characters, and Strings</a></td></tr><tr><td><span class="tocsublinknumber">1.9<tt>&nbsp;</tt></span><a href="#(part._im~3aintsize)" class="tocsubseclink" data-pltdoc="x">Integers</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.3.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;5.3.2&quot;);">top</a></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Inside: Racket C API&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="im_values_types.html" title="forward to &quot;2 Values and Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._overview)"></a>Overview</h3><h4>1.1<tt>&nbsp;</tt><a name="(part.__.Scheme__versus__.Racket_)"></a>&ldquo;Scheme&rdquo; versus &ldquo;Racket&rdquo;</h4><p>The old name for Racket was &ldquo;PLT Scheme,&rdquo; and the core compiler and
run-time system used to be called &ldquo;MzScheme.&rdquo; The old names are
entrenched in Racket internals, to the point that most C bindings
defined in this manual start with <span class="stt">scheme_</span>. They all should be
renamed to start <span class="stt">racket_</span>.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Building_.Racket_from_.Source)"></a>Building Racket from Source</h4><p>The normal Racket distribution includes <span class="stt">".rkt"</span> sources for
collection-based libraries. After modifying library files, run
<span class="stt">raco setup</span> (see <a href="../raco/setup.html" data-pltdoc="x"><span class="stt">raco setup</span>: Installation Management</a>) to rebuild installed
libraries.</p><p>The normal Racket distribution does not include the C sources for
Racket&rsquo;s run-time system. To build Racket from scratch, download a
source distribution, or get the latest from the <span class="stt">git</span> repository at
<a href="https://github.com/plt/racket"><span class="url">https://github.com/plt/racket</span></a>. Detailed build instructions are
in the <span class="stt">"README"</span> file in the top-level <span class="stt">"src"</span>
directory.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.C.G.C_versus_3m)"></a>CGC versus 3m</h4><p>Before mixing any C code with Racket, first decide whether to use the
<span style="font-weight: bold">3m</span> variant of Racket, the <span style="font-weight: bold">CGC</span> variant of Racket, or
both:</p><ul><li><p><span style="font-weight: bold"><a name="(idx._(gentag._0._(lib._scribblings/inside/inside..scrbl)))"></a>3m</span> : the main variant of Racket, which
uses <span style="font-style: italic">precise</span> garbage collection instead of conservative
garbage collection, and it may move objects in memory during a
collection.</p></li><li><p><span style="font-weight: bold"><a name="(idx._(gentag._1._(lib._scribblings/inside/inside..scrbl)))"></a>CGC</span> : the original variant of Racket, where
memory management depends on a <span style="font-style: italic">conservative</span> garbage
collector. The conservative garbage collector can automatically find
references to managed values from C local variables and (on some
platforms) static variables.</p></li></ul><p>At the C level, working with CGC can be much easier than working with
3m, but overall system performance is typically better with 3m.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._.Writing_.Racket_.Extensions)"></a><a name="(idx._(gentag._2._(lib._scribblings/inside/inside..scrbl)))"></a>Writing Racket Extensions</h4><p>The process of creating an extension for 3m or CGC is essentially the
same, but the process for 3m is most easily understood as a variant of
the process for CGC.</p><h5>1.4.1<tt>&nbsp;</tt><a name="(part._.C.G.C_.Extensions)"></a>CGC Extensions</h5><p>To write a C/C++-based extension for Racket CGC, follow these
steps:</p><ul><li><p><a name="(idx._(gentag._3._(lib._scribblings/inside/inside..scrbl)))"></a>For each C/C++ file that uses
Racket library functions, <span class="stt">#include</span> the file
<a name="(idx._(gentag._4._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"escheme.h"</span>.</p><p>This file is distributed with the Racket software in an
<span class="stt">"include"</span> directory, but if <span class="stt">raco ctool</span> is used to
compile, this path is found automatically.</p></li><li><p>Define the C function <span class="stt">scheme_initialize</span>, which takes a
<span class="stt">Scheme_Env*</span> namespace (see <a href="im_env.html" data-pltdoc="x">Namespaces and Modules</a>) and returns a
<span class="stt">Scheme_Object*</span> Racket value.</p><p>This initialization function can install new global primitive
procedures or other values into the namespace, or it can simply
return a Racket value. The initialization function is called when the
extension is loaded with <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span> the first time in a
given <a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a>; the return value from <span class="stt">scheme_initialize</span> is used
as the return value for <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span>. The namespace
provided to <span class="stt">scheme_initialize</span> is the current namespace when
<span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span> is called.</p></li><li><p>Define the C function <span class="stt">scheme_reload</span>, which has the same
arguments and return type as <span class="stt">scheme_initialize</span>.</p><p>This function is called if <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span> is called a second
time (or more times) for an extension in a given <a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a>. Like
<span class="stt">scheme_initialize</span>, the return value from this function is the
return value for <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span>.</p></li><li><p>Define the C function <span class="stt">scheme_module_name</span>, which takes
no arguments and returns a <span class="stt">Scheme_Object*</span> value, either a
symbol or <a href="im_values_types.html#%28cpp._scheme_false%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_false</span></a>.</p><p>The function should return a symbol when the effect of calling
<span class="stt">scheme_initialize</span> and <span class="stt">scheme_reload</span> is only to declare
a module with the returned name. This function is called when the
extension is loaded to satisfy a <span class="RktSym"><a href="../reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span> declaration.</p><p>The <span class="stt">scheme_module_name</span> function may be called before
<span class="stt">scheme_initialize</span> and <span class="stt">scheme_reload</span>, after those
functions, or both before and after, depending on how the extension
is loaded and re-loaded.</p></li><li><p>Compile the extension C/C++ files to create platform-specific
object files.</p><p>The <a name="(idx._(gentag._5._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">raco ctool</span> compiler, which is distributed with Racket,
compiles plain C files when the <a name="(idx._(gentag._6._(lib._scribblings/inside/inside..scrbl)))"></a><span class="nobreak"><span class="stt">--cc</span></span> flag is
specified. More precisely, <span class="stt">raco ctool</span> does not compile the files itself,
but it locates a C compiler on the system and launches it with the
appropriate compilation flags.  If the platform is a relatively
standard Unix system, a Windows system with either Microsoft&rsquo;s C
compiler or <span class="stt">gcc</span> in the path, or a Mac OS X system with Apple&rsquo;s
developer tools installed, then using <span class="stt">raco ctool</span> is typically easier than
working with the C compiler directly. Use the <a name="(idx._(gentag._7._(lib._scribblings/inside/inside..scrbl)))"></a><span class="nobreak"><span class="stt">--cgc</span></span>
flag to indicate that the build is for use with Racket CGC.</p></li><li><p>Link the extension C/C++ files with
<a name="(idx._(gentag._8._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"mzdyn.o"</span> (Unix, Mac OS X) or
<a name="(idx._(gentag._9._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"mzdyn.obj"</span> (Windows) to create a shared object. The
resulting shared object should use the extension <span class="stt">".so"</span> (Unix),
<span class="stt">".dll"</span> (Windows), or <span class="stt">".dylib"</span> (Mac OS X).</p><p>The <span class="stt">"mzdyn"</span> object file is distributed in the installation&rsquo;s
<span class="stt">"lib"</span> directory. For Windows, the object file is in a
compiler-specific sub-directory of <span class="stt">"racket\lib"</span>.</p><p>The <span class="stt">raco ctool</span> compiler links object files into an extension when the
<a name="(idx._(gentag._10._(lib._scribblings/inside/inside..scrbl)))"></a><span class="nobreak"><span class="stt">--ld</span></span> flag is specified, automatically locating
<span class="stt">"mzdyn"</span>. Again, use the <span class="nobreak"><span class="stt">--cgc</span></span> flag with <span class="stt">raco ctool</span>.</p></li><li><p>Load the shared object within Racket using
<span class="RktPn">(</span><span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span><span class="stt"> </span><span class="RktVar">path</span><span class="RktPn">)</span>, where <span class="RktVar">path</span> is the name of
the extension file generated in the previous step.</p><p>Alternately, if the extension defines a module (i.e.,
<span class="stt">scheme_module_name</span> returns a symbol), then place the shared
object in a special directory with a special name, so that it is
detected by the module loader when <span class="RktSym"><a href="../reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span> is used. The
special directory is a platform-specific path that can be obtained by
evaluating <span class="RktPn">(</span><span class="RktSym"><a href="../reference/Manipulating_Paths.html#%28def._%28%28quote._~23~25kernel%29._build-path%29%29" class="RktValLink" data-pltdoc="x">build-path</a></span><span class="stt"> </span><span class="RktVal">"compiled"</span><span class="stt"> </span><span class="RktVal">"native"</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/runtime.html#%28def._%28%28quote._~23~25kernel%29._system-library-subpath%29%29" class="RktValLink" data-pltdoc="x">system-library-subpath</a></span><span class="RktPn">)</span><span class="RktPn">)</span>; see <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._load%2Fuse-compiled%29%29" class="RktValLink" data-pltdoc="x">load/use-compiled</a></span> for more
information.  For example, if the shared object&rsquo;s name is
<span class="stt">"example_rkt.dll"</span>, then <span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="stt"> </span><span class="RktVal">"example.rkt"</span><span class="RktPn">)</span> will
be redirected to <span class="stt">"example_rkt.dll"</span> if the latter is placed in
the sub-directory <span class="RktPn">(</span><span class="RktSym"><a href="../reference/Manipulating_Paths.html#%28def._%28%28quote._~23~25kernel%29._build-path%29%29" class="RktValLink" data-pltdoc="x">build-path</a></span><span class="stt"> </span><span class="RktVal">"compiled"</span><span class="stt"> </span><span class="RktVal">"native"</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/runtime.html#%28def._%28%28quote._~23~25kernel%29._system-library-subpath%29%29" class="RktValLink" data-pltdoc="x">system-library-subpath</a></span><span class="RktPn">)</span><span class="RktPn">)</span> and if <span class="stt">"example.rkt"</span> does not
exist or has an earlier timestamp.</p><p>Note that <span class="RktPn">(</span><span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span><span class="stt"> </span><span class="RktVar">path</span><span class="RktPn">)</span> within a <span class="RktSym"><a href="../reference/module.html#%28form._%28%28quote._~23~25kernel%29._module%29%29" class="RktStxLink" data-pltdoc="x">module</a></span>
does <span style="font-style: italic">not</span> introduce the extension&rsquo;s definitions into the
module, because <span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._load-extension%29%29" class="RktValLink" data-pltdoc="x">load-extension</a></span> is a run-time operation. To
introduce an extension&rsquo;s bindings into a module, make sure that the
extension defines a module, put the extension in the
platform-specific location as described above, and use
<span class="RktSym"><a href="../reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span>.</p></li></ul><p><a name="(idx._(gentag._11._(lib._scribblings/inside/inside..scrbl)))"></a><span style="font-weight: bold">IMPORTANT:</span> With Racket CGC, Racket
values are garbage collected using a conservative garbage collector,
so pointers to Racket objects can be kept in registers, stack
variables, or structures allocated with <a href="im_memoryalloc.html#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>. However,
static variables that contain pointers to collectable memory must be
registered using <a href="im_memoryalloc.html#%28cpp._scheme_register_extension_global%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_extension_global</span></a> (see
<a href="im_memoryalloc.html" data-pltdoc="x">Memory Allocation</a>); even then, such static variables must be
thread-local (in the OS-thread sense) to work with multiple
<a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a>s (see <a href="#%28part._places%29" data-pltdoc="x">Racket and Places</a>).</p><p>As an example, the following C code defines an extension that returns
<span class="RktVal">"hello world"</span> when it is loaded:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "escheme.h"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_initialize(Scheme_Env *env) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_make_utf8_string("hello world");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_reload(Scheme_Env *env) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_initialize(env); /* Nothing special for reload */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_module_name() {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_false;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>Assuming that this code is in the file <span class="stt">"hw.c"</span>, the extension
is compiled on Unix with the following two commands:</p><p><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --cgc --cc hw.c</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --cgc --ld hw.so hw.o</span></div></p><p>(Note that the <span class="nobreak"><span class="stt">--cgc</span></span>, <span class="nobreak"><span class="stt">--cc</span></span>, and <span class="nobreak"><span class="stt">--ld</span></span> flags are each
prefixed by two dashes, not one.)</p><p>The <span class="stt">"collects/mzscheme/examples"</span> directory in the Racket
distribution contains additional examples.</p><h5>1.4.2<tt>&nbsp;</tt><a name="(part._3m_.Extensions)"></a>3m Extensions</h5><p>To build an extension to work with Racket 3m, the CGC instructions
must be extended as follows:</p><ul><li><p>Adjust code to cooperate with the garbage collector as
described in <a href="im_memoryalloc.html#%28part._im~3a3m%29" data-pltdoc="x">Cooperating with 3m</a>. Using <span class="stt">raco ctool</span> with the
<a name="(idx._(gentag._12._(lib._scribblings/inside/inside..scrbl)))"></a><span class="nobreak"><span class="stt">--xform</span></span> might convert your code to implement part of
the conversion, as described in <a href="im_memoryalloc.html#%28part._im~3a3m~3amzc%29" data-pltdoc="x">Local Pointers and <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">--xform</span></span></a>.</p></li><li><p>In either your source in the in compiler command line,
<span class="stt">#define</span> <span class="stt">MZ_PRECISE_GC</span> before including
<span class="stt">"escheme.h"</span>. When using <span class="stt">raco ctool</span> with the <span class="nobreak"><span class="stt">--cc</span></span> and
<a name="(idx._(gentag._13._(lib._scribblings/inside/inside..scrbl)))"></a><span class="nobreak"><span class="stt">--3m</span></span> flags, <span class="stt">MZ_PRECISE_GC</span> is automatically
defined.</p></li><li><p>Link with <a name="(idx._(gentag._14._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"mzdyn3m.o"</span> (Unix, Mac OS X) or
<a name="(idx._(gentag._15._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"mzdyn3m.obj"</span> (Windows) to create a shared
object.  When using <span class="stt">raco ctool</span>, use the <span class="nobreak"><span class="stt">--ld</span></span> and <span class="nobreak"><span class="stt">--3m</span></span> flags
to link to these libraries.</p></li></ul><p>For a relatively simple extension <span class="stt">"hw.c"</span>, the extension is
compiled on Unix for 3m with the following three commands:</p><p><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --xform hw.c</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --3m --cc hw.3m.c</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --3m --ld hw.so hw_3m.o</span></div></p><p>Some examples in <span class="stt">"collects/mzscheme/examples"</span> work with
Racket 3m in this way. A few examples are manually instrumented, in
which case the <span class="nobreak"><span class="stt">--xform</span></span> step should be skipped.</p><h5>1.4.3<tt>&nbsp;</tt><a name="(part._.Declaring_a_.Module_in_an_.Extension)"></a>Declaring a Module in an Extension</h5><p>To create an extension that behaves as a module, return a symbol from
<span class="stt">scheme_module_name</span>, and have <span class="stt">scheme_initialize</span> and
<span class="stt">scheme_rename</span> declare a module using <a href="im_env.html#%28cpp._scheme_primitive_module%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_primitive_module</span></a>.</p><p>For example, the following extension implements a module named
<span class="RktSym">hello</span> that exports a binding <span class="RktSym">greeting</span>:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "escheme.h"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_initialize(Scheme_Env *env) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Env *mod_env;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mod_env = scheme_primitive_module(scheme_intern_symbol("hi"),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">env);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_add_global("greeting",</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_make_utf8_string("hello"),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">mod_env);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_finish_primitive_module(mod_env);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_void;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_reload(Scheme_Env *env) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_initialize(env); /* Nothing special for reload */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *scheme_module_name() {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_intern_symbol("hi");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>This extension could be compiled for 3m on i386 Linux, for
example, using the following sequence of <span class="stt">mzc</span> commands:</p><p><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --xform hi.c</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --3m --cc hi.3m.c</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mkdir -p compiled/native/i386-linux/3m</span></div><div class="SIntrapara"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --3m --ld compiled/native/i386-linux/3m/hi_rkt.so hi_3m.o</span></div></p><p>The resulting module can be loaded with</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hi.rkt"</span><span class="RktPn">)</span></p></blockquote><h4>1.5<tt>&nbsp;</tt><a name="(part._embedding)"></a><a name="(idx._(gentag._16._(lib._scribblings/inside/inside..scrbl)))"></a>Embedding Racket into a Program</h4><p>Like creating extensions, the embedding process for Racket CGC or
Racket 3m is essentially the same, but the process for Racket
3m is most easily understood as a variant of the process for
Racket CGC.</p><h5>1.5.1<tt>&nbsp;</tt><a name="(part._.C.G.C_.Embedding)"></a>CGC Embedding</h5><p>To embed Racket CGC in a program, follow these steps:</p><ul><li><p>Locate or build the Racket CGC libraries. Since the
standard distribution provides 3m libraries, only, you will most
likely have to build from source.</p><p>On Unix, the libraries are <a name="(idx._(gentag._17._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket.a"</span>
and <a name="(idx._(gentag._18._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libmzgc.a"</span> (or
<a name="(idx._(gentag._19._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket.so"</span> and
<a name="(idx._(gentag._20._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libmzgc.so"</span> for a dynamic-library build, with
<a name="(idx._(gentag._21._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket.la"</span> and
<a name="(idx._(gentag._22._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libmzgc.la"</span> files for use with
<span class="stt">libtool</span>). Building from source and installing places the
libraries into the installation&rsquo;s <span class="stt">"lib"</span> directory. Be sure
to build the CGC variant, since the default is 3m.</p><p>On Windows, stub libraries for use with Microsoft tools are
<span class="stt">"libracket<span style="font-style: italic">x</span>.lib"</span> and
<span class="stt">"libmzgc<span style="font-style: italic">x</span>.lib"</span> (where <span style="font-style: italic">x</span> represents the
version number) are in a compiler-specific directory in
<span class="stt">"racket\lib"</span>. These libraries identify the bindings that are
provided by <span class="stt">"libracket<span style="font-style: italic">x</span>.dll"</span> and
<span class="stt">"libmzgc<span style="font-style: italic">x</span>.dll"</span> &#8212;<wbr></wbr> which are typically installed
in <span class="stt">"racket\lib"</span>. When linking with Cygwin, link to
<span class="stt">"libracket<span style="font-style: italic">x</span>.dll"</span> and
<span class="stt">"libmzgc<span style="font-style: italic">x</span>.dll"</span> directly.  At run time, either
<span class="stt">"libracket<span style="font-style: italic">x</span>.dll"</span> and
<span class="stt">"libmzgc<span style="font-style: italic">x</span>.dll"</span> must be moved to a location in the
standard DLL search path, or your embedding application must
&ldquo;delayload&rdquo; link the DLLs and explicitly load them before
use. (<span class="stt">"Racket.exe"</span> and <span class="stt">"GRacket.exe"</span> use the latter
strategy.)</p><p>On Mac OS X, dynamic libraries are provided by the
<span class="stt">"Racket"</span> framework, which is typically installed in
<span class="stt">"lib"</span> sub-directory of the installation. Supply
<span class="stt">-framework Racket</span> to <span class="stt">gcc</span> when linking, along
with <span class="stt">-F</span> and a path to the <span class="stt">"lib"</span> directory. Beware
that CGC and 3m libraries are installed as different versions within
a single framework, and installation marks one version or the other
as the default (by setting symbolic links); install only CGC to
simplify accessing the CGC version within the framework.  At run
time, either <span class="stt">"Racket.framework"</span> must be moved to a
location in the standard framework search path, or your embedding
executable must provide a specific path to the framework (possibly
an executable-relative path using the Mach-O <span class="stt">@executable_path</span>
prefix).</p></li><li><p>For each C/C++ file that uses Racket library functions,
<span class="stt">#include</span> the file <a name="(idx._(gentag._23._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"scheme.h"</span>.</p><p>The C preprocessor symbol <span class="stt">SCHEME_DIRECT_EMBEDDED</span> is defined
as <span class="stt">1</span> when <span class="stt">"scheme.h"</span> is <span class="stt">#include</span>d, or as
<span class="stt">0</span> when <span class="stt">"escheme.h"</span> is <span class="stt">#include</span>d.</p><p>The <span class="stt">"scheme.h"</span> file is distributed with the Racket software in
the installation&rsquo;s <span class="stt">"include"</span> directory. Building and
installing from source also places this file in the installation&rsquo;s
<span class="stt">"include"</span> directory.</p></li><li><p>Start your main program through the <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> (or
<a href="im_memoryalloc.html#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a>) trampoline, and put all uses of
Racket functions inside the function passed to
<a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a>. The <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> function
registers the current C stack location with the memory manager. It
also creates the initial namespace <span class="stt">Scheme_Env*</span> by calling
<a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> and passing the result to the function
provided to <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a>. (The
<a href="im_memoryalloc.html#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a> trampoline registers the C stack with
the memory manager without creating a namespace.)</p><p>On 32-bit Windows, when support for parallelism is enabled in the Racket
build (as is the default), then before calling
<a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a>, your embedding application must first call
<a href="im_memoryalloc.html#%28cpp._scheme_register_tls_space%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_tls_space</span></a>:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_register_tls_space(&amp;tls_space, 0);</span></span></p></td></tr></table></p><p>where <span class="stt">tls_space</span> is declared as a thread-local pointer variable
in the main executable (i.e., not in a dynamically linked DLL):</p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">static __declspec(thread) void *tls_space;</span></span></p></td></tr></table></li><li><p>Configure the namespace by adding module declarations. The
initial namespace contains declarations only for a few primitive
modules, such as <span class="RktVal">'</span><span class="RktVal">#%kernel</span>, and no bindings are imported
into the top-level environment.</p><p>To embed a module like <a href="../reference/index.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">racket/base</span></a> (along with all
its dependencies), use <span class="stt">raco ctool --c-mods</span>, which generates a C file
that contains modules in bytecode form as encapsulated in a static
array. The generated C file defines a <span class="stt">declare_modules</span>
function that takes a <span class="stt">Scheme_Env*</span>, installs the modules into
the environment, and adjusts the module name resolver to access the
embedded declarations.</p><p>Alternately, use <a href="Flags_and_Hooks.html#%28cpp._scheme_set_collects_path%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_collects_path</span></a> and
<a href="Flags_and_Hooks.html#%28cpp._scheme_init_collection_paths%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_init_collection_paths</span></a> to configure and install a path
for finding modules at run time.</p></li><li><p>Access Racket through <a href="Miscellaneous_Utilities.html#%28cpp._scheme_dynamic_require%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_dynamic_require</span></a>,
<a href="Miscellaneous_Utilities.html#%28cpp._scheme_load%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_load</span></a>, <a href="Evaluation.html#%28cpp._scheme_eval%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_eval</span></a>, and/or other functions
described in this manual.</p><p>If the embedding program configures built-in parameters in a way
that should be considered part of the default configuration, then
call <a href="Flags_and_Hooks.html#%28cpp._scheme_seal_parameters%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_seal_parameters</span></a> afterward. The snapshot of
parameter values taken by <a href="Flags_and_Hooks.html#%28cpp._scheme_seal_parameters%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_seal_parameters</span></a> is used for
certain privileged operations, such as installing a <span class="planetName">PLaneT</span>
package.</p></li><li><p>Compile the program and link it with the Racket libraries.</p></li></ul><p><a name="(idx._(gentag._24._(lib._scribblings/inside/inside..scrbl)))"></a>With Racket CGC, Racket values are
garbage collected using a conservative garbage collector, so pointers
to Racket objects can be kept in registers, stack variables, or
structures allocated with <a href="im_memoryalloc.html#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>. In an embedding
application on some platforms, static variables are also automatically
registered as roots for garbage collection (but see notes below
specific to Mac OS X and Windows).</p><p>For example, the following is a simple embedding program which
evaluates all expressions provided on the command line and displays
the results, then runs a <span class="RktSym"><a href="../reference/Reading.html#%28def._%28%28quote._~23~25kernel%29._read%29%29" class="RktValLink" data-pltdoc="x">read</a></span>-<span class="RktSym"><a href="../reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29" class="RktValLink" data-pltdoc="x">eval</a></span>-<span class="RktSym"><a href="../reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._print%29%29" class="RktValLink" data-pltdoc="x">print</a></span>
loop. Run</p><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco ctool --c-mods base.c ++lib racket/base</span></p><p>to generate <span class="stt">"base.c"</span>, which encapsulates <span class="RktSym">racket/base</span>
and all of its transitive imports (so that they need not be found
separately a run time).</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "scheme.h"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "base.c"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">static int run(Scheme_Env *e, int argc, char *argv[])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *curout;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int i;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mz_jmp_buf * volatile save, fresh;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">/* Declare embedded modules in "base.c": */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">declare_modules(e);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_namespace_require(scheme_intern_symbol("racket/base"));</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">curout = scheme_get_param(scheme_current_config(),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZCONFIG_OUTPUT_PORT);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (i = 1; i &lt; argc; i++) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">save = scheme_current_thread-&gt;error_buf;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = &amp;fresh;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (scheme_setjmp(scheme_error_buf)) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = save;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return -1; /* There was an error */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">} else {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Scheme_Object *v, *a[2];</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v = scheme_eval_string(argv[i], e);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_display(v, curout);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_display(scheme_make_char('\n'), curout);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* read-eval-print loop, uses initial Scheme_Env: */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">a[0] = scheme_intern_symbol("racket/base");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">a[1] = scheme_intern_symbol("read-eval-print-loop");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_apply(scheme_dynamic_require(2, a), 0, NULL);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = save;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return 0;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int main(int argc, char *argv[])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_main_setup(1, run, argc, argv);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>On Mac OS X, or on Windows when Racket is compiled to a DLL
using Cygwin, the garbage collector cannot find static variables
automatically. In that case, <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> must be called with a
non-zero first argument.</p><p>On Windows (for any other build mode), the garbage collector finds
static variables in an embedding program by examining all memory
pages. This strategy fails if a program contains multiple Windows
threads; a page may get unmapped by a thread while the collector is
examining the page, causing the collector to crash. To avoid this
problem, call <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> with a non-zero first argument.</p><p>When an embedding application calls <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> with a non-zero
first argument, it must register each of its static variables with
<span class="stt">MZ_REGISTER_STATIC</span> if the variable can contain a GCable
pointer. For example, if <span class="stt">curout</span> above is made <span class="stt">static</span>, then
<span class="stt">MZ_REGISTER_STATIC(curout)</span> should be inserted before the call to
<a href="config.html#%28cpp._scheme_get_param%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_get_param</span></a>.</p><p>When building an embedded Racket CGC to use SenoraGC (SGC) instead of
the default collector, <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> must be called with a
non-zero first argument.  See <a href="im_memoryalloc.html" data-pltdoc="x">Memory Allocation</a> for more
information.</p><h5>1.5.2<tt>&nbsp;</tt><a name="(part._3m_.Embedding)"></a>3m Embedding</h5><p>Racket 3m can be embedded mostly the same as Racket, as long as the
embedding program cooperates with the precise garbage collector as
described in <a href="im_memoryalloc.html#%28part._im~3a3m%29" data-pltdoc="x">Cooperating with 3m</a>.</p><p>In either your source in the in compiler command line, <span class="stt">#define</span>
<span class="stt">MZ_PRECISE_GC</span> before including <span class="stt">"scheme.h"</span>. When using
<span class="stt">raco ctool</span> with the <span class="nobreak"><span class="stt">--cc</span></span> and <span class="nobreak"><span class="stt">--3m</span></span> flags, <span class="stt">MZ_PRECISE_GC</span>
is automatically defined.</p><p>In addition, some library details are different:</p><ul><li><p>On Unix, the library is just
<a name="(idx._(gentag._25._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket3m.a"</span> (or
<a name="(idx._(gentag._26._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket3m.so"</span> for a dynamic-library build,
with <a name="(idx._(gentag._27._(lib._scribblings/inside/inside..scrbl)))"></a><span class="stt">"libracket3m.la"</span> for use with
<span class="stt">libtool</span>). There is no separate library for 3m analogous to
CGC&rsquo;s <span class="stt">"libmzgc.a"</span>.</p></li><li><p>On Windows, the stub library for use with Microsoft tools is
<span class="stt">"libracket3m<span style="font-style: italic">x</span>.lib"</span> (where <span style="font-style: italic">x</span> represents the
version number). This library identifies the bindings that are
provided by <span class="stt">"libracket3m<span style="font-style: italic">x</span>.dll"</span>.  There is no
separate library for 3m analogous to CGC&rsquo;s
<span class="stt">"libmzgc<span style="font-style: italic">x</span>.lib"</span>.</p></li><li><p>On Mac OS X, 3m dynamic libraries are provided by the
<span class="stt">"Racket"</span> framework, just as for CGC, but as a version
suffixed with <span class="stt">"_3m"</span>.</p></li></ul><p>For Racket 3m, an embedding application must call <a href="im_memoryalloc.html#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a>
with a non-zero first argument.</p><p>The simple embedding program from the previous section can be
processed by <span class="stt">raco ctool --xform</span>, then compiled and linked with
Racket 3m.  Alternately, the source code can be extended to work with
either CGC or 3m depending on whether <span class="stt">MZ_PRECISE_GC</span> is defined
on the compiler&rsquo;s command line:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "scheme.h"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">#include "base.c"</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">static int run(Scheme_Env *e, int argc, char *argv[])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *curout = NULL, *v = NULL, *a[2] = {NULL, NULL};</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Config *config = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int i;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mz_jmp_buf * volatile save = NULL, fresh;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(8);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, e);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, curout);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(2, save);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(3, config);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(4, v);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_ARRAY_VAR_IN_REG(5, a, 2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">declare_modules(e);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">v = scheme_intern_symbol("racket/base");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_namespace_require(v);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">config = scheme_current_config();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">curout = scheme_get_param(config, MZCONFIG_OUTPUT_PORT);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (i = 1; i &lt; argc; i++) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">save = scheme_current_thread-&gt;error_buf;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = &amp;fresh;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (scheme_setjmp(scheme_error_buf)) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = save;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return -1; /* There was an error */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">} else {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v = scheme_eval_string(argv[i], e);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_display(v, curout);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v = scheme_make_char('\n');</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_display(v, curout);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* read-eval-print loop, uses initial Scheme_Env: */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">a[0] = scheme_intern_symbol("racket/base");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">a[1] = scheme_intern_symbol("read-eval-print-loop");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v = scheme_dynamic_require(2, a);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_apply(v, 0, NULL);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_current_thread-&gt;error_buf = save;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return 0;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int main(int argc, char *argv[])</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return scheme_main_setup(1, run, argc, argv);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>Strictly speaking, the <span class="stt">config</span> and <span class="stt">v</span> variables above need
not be registered with the garbage collector, since their values are
not needed across function calls that allocate. The code is much
easier to maintain, however, when all local variables are registered
and when all temporary values are put into variables.</p><h4>1.6<tt>&nbsp;</tt><a name="(part._places)"></a>Racket and Places</h4><p>Each Racket <a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a> corresponds to a separate OS-implemented
thread. Each place has its own memory manager. Pointers to GC-managed
memory cannot be communicated from one place to another, because such
pointers in one place are invisible to the memory manager of another
place.</p><p>When <a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a> support is enabled, static variables in an
extension or an embedding generally cannot hold pointers to GC-managed
memory, since the static variable may be used from multiple places.
For some OSes, a static variable can be made thread-local, in which
case it has a different address in each OS thread, and each different
address can be registered with the GC for a given place.</p><p>The OS thread that originally calls <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> is the OS
thread of the original place. When <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> is called a
second time to reset the interpreter, it can be called in an OS thread
that is different from the original call to
<a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a>. Thereafter, the new thread is the OS thread
for the original place.</p><h4>1.7<tt>&nbsp;</tt><a name="(part._.Racket_and_.Threads)"></a>Racket and Threads</h4><p>Racket implements threads for Racket programs without aid from the
operating system, so that Racket threads are cooperative from the
perspective of C code. On Unix, stand-alone Racket uses a single
OS-implemented thread. On Windows and Mac OS X, stand-alone
Racket uses a few private OS-implemented threads for background
tasks, but these OS-implemented threads are never exposed by the
Racket API.</p><p>In an embedding application, Racket can co-exist with additional
OS-implemented threads, but the additional OS threads must not call
any <span class="stt">scheme_</span> function.  Only the OS thread representing a
particular <a href="../reference/places.html#%28tech._place%29" class="techoutside" data-pltdoc="x"><span class="techinside">place</span></a> can call <span class="stt">scheme_</span> functions. (This
restriction is stronger than saying all calls for a given place must
be serialized across threads. Racket relies on properties of specific
threads to avoid stack overflow and garbage collection.) For the
original place, only the OS thread used to call <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a>
can call <span class="stt">scheme_</span> functions. For any other place, only the OS
thread that is created by Racket for the place can be used to call
<span class="stt">scheme_</span> functions.</p><p>See <a href="threads.html" data-pltdoc="x">Threads</a> for more information about threads, including
the possible effects of Racket&rsquo;s thread implementation on extension
and embedding C code.</p><h4>1.8<tt>&nbsp;</tt><a name="(part._im~3aunicode)"></a>Racket, Unicode, Characters, and Strings</h4><p>A character in Racket is a Unicode code point. In C, a character
value has type <span class="stt">mzchar</span>, which is an alias for <span class="stt">unsigned</span> &#8212;<wbr></wbr>
which is, in turn, 4 bytes for a properly compiled Racket. Thus, a
<span class="stt">mzchar*</span> string is effectively a UCS-4 string.</p><p>Only a few Racket functions use <span class="stt">mzchar*</span>. Instead, most
functions accept <span class="stt">char*</span> strings. When such byte strings are to be
used as a character strings, they are interpreted as UTF-8
encodings. A plain ASCII string is always acceptable in such cases,
since the UTF-8 encoding of an ASCII string is itself.</p><p>See also <a href="im_values_types.html#%28part._im~3astrings%29" data-pltdoc="x">Strings</a> and <a href="im_encodings.html" data-pltdoc="x">String Encodings</a>.</p><h4>1.9<tt>&nbsp;</tt><a name="(part._im~3aintsize)"></a>Integers</h4><p>Racket expects to be compiled in a mode where <span class="stt">short</span> is a
16-bit integer, <span class="stt">int</span> is a 32-bit integer, and <span class="stt">intptr_t</span> has
the same number of bits as <span class="stt">void*</span>. The <span class="stt">long</span> type can match
either <span class="stt">int</span> or <span class="stt">intptr_t</span>, depending on the platform.
The <span class="stt">mzlonglong</span> type has
64 bits for compilers that support a 64-bit integer type, otherwise it
is the same as <span class="stt">intptr_t</span>; thus, <span class="stt">mzlonglong</span> tends to match
<span class="stt">long long</span>. The <span class="stt">umzlonglong</span> type is the unsigned version
of <span class="stt">mzlonglong</span>.</p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.3.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;5.3.2&quot;);">top</a></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Inside: Racket C API&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="im_values_types.html" title="forward to &quot;2 Values and Types&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>